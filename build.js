/**
 * Build script for brianvanburken.nl
 *
 * This script post-processes the static HTML files generated by Zola.
 * It performs the following optimizations:
 *
 * 1. Syntax highlighting - Converts code blocks to highlighted HTML using Shiki
 * 2. Footnote processing - Transforms Zola's footnote markup to accessible HTML
 * 3. Abbreviation processing - Expands markdown abbreviations to <abbr> tags
 * 4. CSS inlining - Inlines external stylesheets into <style> tags
 * 5. CSS purging - Removes unused CSS rules per-page using PurgeCSS
 * 6. Class name minification - Shortens class names (e.g., "shiki_0_1" -> "a")
 * 7. HTML minification - Removes optional tags, whitespace, and comments
 *
 * Usage: node build.js
 * Environment: BUILD_DIR can override the default "public" directory
 */

import { readFile, writeFile, readdir, unlink } from "node:fs/promises";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { load } from "cheerio";
import { minify as minifyCss } from "csso";
import { minify as minifyHtml } from "html-minifier-terser";
import { PurgeCSS } from "purgecss";
import { createHighlighter } from "shiki";

const SOURCE = process.env.BUILD_DIR || "public";
const ROOT = dirname(fileURLToPath(import.meta.url));
const THEME = "ayu-dark";

// Initialize Shiki highlighter with supported languages
const highlighter = await createHighlighter({
  themes: [THEME],
  langs: [
    "css",
    "diff",
    "elixir",
    "elm",
    "html",
    "ini",
    "javascript",
    "json",
    "kotlin",
    "ruby",
    "typescript",
    "shell",
  ],
});

/**
 * Recursively finds all files with a given extension in a directory.
 * @param {string} dir - Directory to search
 * @param {string} ext - File extension to match (e.g., ".html")
 * @returns {Promise<string[]>} Array of absolute file paths
 */
async function findFiles(dir, ext) {
  const files = [];
  const entries = await readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await findFiles(fullPath, ext)));
    } else if (entry.name.endsWith(ext)) {
      files.push(fullPath);
    }
  }
  return files;
}

/**
 * Transforms Zola's footnote markup into accessible HTML structure.
 *
 * Zola outputs footnotes as:
 *   <sup><a href="#1">1</a></sup> ... <div id="1"><sup>1</sup><p>Text</p></div>
 *
 * This transforms them to:
 *   <sup id="fnref:1"><a href="#fn:1">1</a></sup> ... <ol role="doc-endnotes"><li id="fn:1"><p>Text <a href="#fnref:1">↩</a></p></li></ol>
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 */
function processFootnotes($) {
  // Update footnote references with proper IDs and hrefs
  $("sup > a[href^='#']").each(function () {
    const $link = $(this);
    const href = $link.attr("href");
    const match = href.match(/^#(\d+)$/);
    if (match) {
      const fnId = match[1];
      const $sup = $link.parent();
      $sup.attr("id", `fnref:${fnId}`);
      $link.attr("href", `#fn:${fnId}`);
    }
  });

  // Collect footnote definition divs
  const footnoteDivs = [];
  $("div[id]").each(function () {
    const $div = $(this);
    const id = $div.attr("id");
    if (/^\d+$/.test(id)) {
      footnoteDivs.push({ id, $div });
    }
  });

  if (footnoteDivs.length === 0) return;

  // Create accessible footnotes list
  const $ol = $('<ol role="doc-endnotes"></ol>');

  footnoteDivs.forEach(({ id, $div }) => {
    // Remove the redundant <sup>N</sup> number
    $div.find("sup").first().remove();

    // Add back-link to the last paragraph
    const $lastP = $div.find("p").last();
    if ($lastP.length) {
      $lastP.append(`&nbsp;<a href="#fnref:${id}" role="doc-backlink">↩</a>`);
    } else {
      $div.append(`<a href="#fnref:${id}" role="doc-backlink">↩</a>`);
    }

    // Move content to list item
    const $li = $(`<li id="fn:${id}"></li>`);
    $li.append($div.contents());
    $ol.append($li);
    $div.remove();
  });

  // Append footnotes to article or body
  const $article = $("article");
  if ($article.length) {
    $article.find("section").append($ol);
  } else {
    $("body").append($ol);
  }
}

/**
 * Processes markdown abbreviation definitions and wraps matching text in <abbr> tags.
 *
 * Abbreviation syntax: *[ABBR]: Full expansion text
 *
 * Example:
 *   *[HTML]: HyperText Markup Language
 *   The HTML specification...
 *
 * Becomes:
 *   The <abbr title="HyperText Markup Language">HTML</abbr> specification...
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 */
function processAbbreviations($) {
  const abbreviations = {};
  const abbrRegex = /\*\[([^\]]+)\]:\s*(.+)/g;

  // Extract abbreviation definitions from paragraphs
  $("p").each(function () {
    const text = $(this).text();
    let match;
    let hasAbbr = false;

    while ((match = abbrRegex.exec(text)) !== null) {
      abbreviations[match[1]] = match[2].trim();
      hasAbbr = true;
    }
    abbrRegex.lastIndex = 0;

    // Remove paragraph if it only contained abbreviation definitions
    if (hasAbbr) {
      const cleanedText = text.replace(/\*\[[^\]]+\]:\s*.+/g, "").trim();
      if (cleanedText === "") {
        $(this).remove();
      }
    }
  });

  if (Object.keys(abbreviations).length === 0) return;

  // Replace abbreviations in text nodes (excluding code, pre, script, style, abbr)
  const replaceInText = (node) => {
    if (node.type === "text" && node.data) {
      let text = node.data;
      for (const [abbr, title] of Object.entries(abbreviations)) {
        const escapedAbbr = abbr.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const regex = new RegExp(`\\b${escapedAbbr}\\b`, "g");
        text = text.replace(regex, `<abbr title="${title}">${abbr}</abbr>`);
      }
      if (text !== node.data) {
        $(node).replaceWith(text);
      }
    }
  };

  $("body *")
    .not("code, pre, script, style, abbr")
    .contents()
    .each(function () {
      replaceInText(this);
    });
}

/**
 * Applies syntax highlighting to code blocks using Shiki.
 *
 * This function:
 * 1. Highlights code blocks with Shiki (generates inline styles)
 * 2. Converts inline styles to CSS classes (reduces HTML size)
 * 3. Removes default/unnecessary classes (theme defaults)
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 */
function convertCode($) {
  const codeBlocks = $("code");
  if (codeBlocks.length === 0) return;

  // Theme default styles to remove (already set in base CSS)
  const DEFAULT_COLOR_KEY = "COLOR:#BFBDB6";
  const ITALIC_KEY = "FONT-STYLE:ITALIC";
  const BG_KEY = "BACKGROUND-COLOR:#0B0E14";

  let css = "";
  let classCounter = 0;
  const cssMap = {}; // Maps style declarations to class names

  // Regex to extract style attribute from Shiki output
  const styleRegex = /style="([^"]+)"/;

  // Highlight all code blocks
  codeBlocks.each(function () {
    const $code = $(this);
    const $parent = $code.parent();
    const isInlineCode = $parent[0].name !== "pre";

    // Determine language from class or data-lang attribute
    const cls = $code.attr("class");
    const dataLang = $code.attr("data-lang");
    const lang = dataLang
      ? dataLang
      : cls
        ? cls.toString().replace("language-", "").trim()
        : "text";

    const content = $code.text();
    const highlighted = highlighter.codeToHtml(content, { lang, theme: THEME });

    if (isInlineCode) {
      // Extract style with regex instead of creating Cheerio instance
      const match = highlighted.match(styleRegex);
      if (match) $code.attr("style", match[1]);
    } else {
      $parent.replaceWith(`<pre>${highlighted}</pre>`);
    }
  });

  // Convert inline styles to CSS classes for smaller output
  $("*[style]").each(function () {
    const styleContent = $(this).attr("style").trim();
    for (const style of styleContent.split(";")) {
      const styleKey = style.replace(/[\s;]/g, "").toUpperCase();
      if (!styleKey) continue;

      if (!cssMap[styleKey]) {
        const className = `s${classCounter++}`;
        cssMap[styleKey] = className;
        css += `.${className}{${style}}\n`;
      }
      $(this).addClass(cssMap[styleKey]);
    }
    $(this).removeAttr("style");
  });

  if (css) {
    $("body").append(`<style>${css}</style>`);
  }

  // Remove classes for default theme styles (already in base CSS)
  for (const key of [DEFAULT_COLOR_KEY, ITALIC_KEY, BG_KEY]) {
    const cls = cssMap[key];
    if (cls) $(`.${cls}`).removeClass(cls);
  }

  // Clean up nested pre tags (Shiki wraps output in pre)
  $("pre > pre").each(function () {
    $(this).parent().replaceWith($(this).parent().html());
  });

  // Remove Shiki's unused classes from pre elements
  $("pre").removeClass(`shiki ${THEME}`);
}

/**
 * Cleans up span elements and merges adjacent spans with the same class.
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 * @returns {string} Cleaned HTML with merged spans
 */
function cleanupSpans($) {
  // Remove empty spans
  $("span:empty").remove();

  // Unwrap nested spans
  $("span > span:first-child").each(function () {
    $(this).parent().replaceWith($(this).parent().html());
  });

  // Remove unnecessary spans
  $("span").each(function () {
    const content = $(this).text();
    if (content.trim() === "") {
      $(this).replaceWith(content);
    }
    if (!$(this).attr("class") && !$(this).attr("style")) {
      $(this).replaceWith($(this).html());
    }
  });

  // Merge adjacent spans with same class (regex on HTML string)
  const regex =
    /<span class="([a-z0-9_]+)">([^<]*)<\/span>(\s*)<span class="\1">/gm;
  return $.html()
    .replace(regex, '<span class="$1">$2$3')
    .replace(regex, '<span class="$1">$2$3');
}

/**
 * Minifies class names to single/double letters (a, b, ..., z, aa, ab, ...).
 * Updates both element class attributes and CSS selectors.
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 */
function minifyClassNames($) {
  const classMap = {};
  let counter = 0;

  /**
   * Converts a number to a class name (0=a, 25=z, 26=aa, etc.)
   * @param {number} n - Number to convert
   * @returns {string} Class name
   */
  const toClassName = (n) => {
    let name = "";
    do {
      name = String.fromCharCode(97 + (n % 26)) + name;
      n = Math.floor(n / 26) - 1;
    } while (n >= 0);
    return name;
  };

  // Single pass: build map and update elements
  $("[class]").each(function () {
    const classes = $(this).attr("class").split(/\s+/);
    const newClasses = classes
      .map((cls) => {
        if (!cls) return cls;
        if (!classMap[cls]) classMap[cls] = toClassName(counter++);
        return classMap[cls];
      })
      .join(" ");
    $(this).attr("class", newClasses);
  });

  // Single regex replacement for all classes in CSS
  $("style").each(function () {
    const css = $(this)
      .html()
      .replace(/\.([a-z0-9_]+)/g, (match, cls) =>
        classMap[cls] ? `.${classMap[cls]}` : match,
      );
    $(this).html(css);
  });
}

// Shared PurgeCSS instance
const purgeCss = new PurgeCSS();

// Timing stats for processHtml steps (cumulative across all files)
const stats = {
  transforms: 0,
  combineCss: 0,
  purgeCss: 0,
  minifyClasses: 0,
  minifyHtml: 0,
};

/**
 * Processes a single HTML file through all optimization steps.
 *
 * @param {string} filePath - Absolute path to the HTML file
 * @param {string} baseCss - Pre-loaded CSS content to inline
 */
async function processHtml(filePath, baseCss) {
  let content = await readFile(filePath, "utf-8");
  let $ = load(content);

  // Step 1: Custom transforms (footnotes, abbreviations, syntax highlighting)
  let t = performance.now();
  processFootnotes($);
  processAbbreviations($);
  convertCode($);
  stats.transforms += performance.now() - t;

  // Step 2: Combine base CSS with generated styles
  t = performance.now();
  $('link[rel="stylesheet"]').remove();
  const generatedCss = $("style")
    .map(function () {
      return $(this).html();
    })
    .get()
    .join("");
  $("style").remove();
  $("head").append(`<style>${baseCss}${generatedCss}</style>`);
  stats.combineCss += performance.now() - t;

  // Step 3: Per-page CSS purging (remove unused selectors)
  t = performance.now();
  let html = $.html();
  const styleMatch = html.match(/<style>([\s\S]*?)<\/style>/);
  if (styleMatch) {
    const css = styleMatch[1];
    // Exclude style content from analysis to avoid false positives
    const htmlWithoutStyle = html.replace(/<style>[\s\S]*?<\/style>/g, "");
    const purged = await purgeCss.purge({
      content: [{ raw: htmlWithoutStyle, extension: "html" }],
      css: [{ raw: css }],
    });
    if (purged[0]?.css) {
      // Minify CSS after purging
      const minifiedCss = minifyCss(purged[0].css).css;
      html = html.replace(styleMatch[0], `<style>${minifiedCss}</style>`);
    }
  }
  stats.purgeCss += performance.now() - t;

  // Step 4: Minify class names and clean up spans
  t = performance.now();
  $ = load(html);
  minifyClassNames($);
  html = cleanupSpans($);
  stats.minifyClasses += performance.now() - t;

  // Step 5: Final HTML minification
  t = performance.now();
  const minified = await minifyHtml(html, {
    collapseWhitespace: true,
    removeComments: true,
    removeEmptyAttributes: true,
    removeAttributeQuotes: true,
    removeOptionalTags: true,
  });
  stats.minifyHtml += performance.now() - t;

  await writeFile(filePath, minified);
}

/**
 * Logs elapsed time since a start timestamp.
 * @param {string} label - Description of the timed operation
 * @param {number} start - Start timestamp from performance.now()
 */
function logTime(label, start) {
  const elapsed = ((performance.now() - start) / 1000).toFixed(2);
  console.log(`  ${label}: ${elapsed}s`);
}

/**
 * Main build function.
 * Processes all HTML and CSS files in the source directory.
 */
async function build() {
  const start = performance.now();
  const sourceDir = join(ROOT, SOURCE);

  // Load all CSS files into memory
  let stepStart = performance.now();
  const cssFiles = await findFiles(sourceDir, ".css");
  const cssContents = await Promise.all(
    cssFiles.map((file) => readFile(file, "utf-8")),
  );
  const baseCss = cssContents.join("");
  logTime("Load CSS", stepStart);

  // Process each HTML file
  stepStart = performance.now();
  const htmlFiles = await findFiles(sourceDir, ".html");
  console.log(`Processing ${htmlFiles.length} HTML files...`);
  await Promise.all(htmlFiles.map((file) => processHtml(file, baseCss)));
  logTime("Process HTML", stepStart);

  // Clean up CSS files (now inlined)
  stepStart = performance.now();
  await Promise.all(cssFiles.map(unlink));
  logTime("Clean up CSS", stepStart);

  // Log per-step timing breakdown
  console.log("Per-step breakdown (cumulative across all files):");
  for (const [step, ms] of Object.entries(stats)) {
    console.log(`  ${step}: ${(ms / 1000).toFixed(2)}s`);
  }

  const elapsed = ((performance.now() - start) / 1000).toFixed(2);
  console.log(`Build complete in ${elapsed}s`);
}

// Run build
build().catch((err) => {
  console.error(err);
  process.exit(1);
});
