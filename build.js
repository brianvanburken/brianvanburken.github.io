/**
 * Build script for brianvanburken.nl
 *
 * This script post-processes the static HTML files generated by Zola.
 * It performs the following optimizations:
 *
 * 1. Syntax highlighting - Converts code blocks to highlighted HTML using Shiki
 * 2. Footnote processing - Transforms Zola's footnote markup to accessible HTML
 * 3. Abbreviation processing - Expands markdown abbreviations to <abbr> tags
 * 4. CSS inlining - Inlines external stylesheets into <style> tags
 * 5. CSS purging - Removes unused CSS rules per-page using PurgeCSS
 * 6. Class name minification - Shortens class names (e.g., "shiki_0_1" -> "a")
 * 7. HTML minification - Removes optional tags, whitespace, and comments
 *
 * Usage: node build.js
 * Environment: BUILD_DIR can override the default "public" directory
 */

import { readFile, writeFile, readdir, unlink } from "node:fs/promises";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { minify as minifyCss } from "csso";
import { minify as minifyHtml } from "html-minifier-terser";
import { PurgeCSS } from "purgecss";
import { createHighlighter } from "shiki";

const SOURCE = process.env.BUILD_DIR || "public";
const ROOT = dirname(fileURLToPath(import.meta.url));
const THEME = "ayu-dark";

// Default styles to skip (already in base CSS)
const SKIP_STYLES = new Set([
  "color:#BFBDB6",
  "font-style:italic",
  "background-color:#0B0E14",
]);

// Global style-to-class map and CSS (shared across all files)
const styleToClass = {};
let shikiCss = "";
let classCounter = 0;

/**
 * Shiki transformer that converts inline styles to CSS classes.
 * This runs during highlighting, avoiding a separate DOM traversal.
 */
const classTransformer = {
  pre(node) {
    // Remove Shiki's default classes and styles from pre
    delete node.properties.class;
    delete node.properties.style;
    delete node.properties.tabindex;
  },
  span(node) {
    const style = node.properties?.style;
    if (!style) return;

    const classes = [];
    for (const part of style.split(";")) {
      const normalized = part.replace(/\s/g, "").toLowerCase();
      if (!normalized || SKIP_STYLES.has(normalized)) continue;

      if (!styleToClass[normalized]) {
        styleToClass[normalized] = `s${classCounter++}`;
        shikiCss += `.${styleToClass[normalized]}{${part.trim()}}\n`;
      }
      classes.push(styleToClass[normalized]);
    }

    delete node.properties.style;
    if (classes.length > 0) {
      node.properties.class = classes.join(" ");
    }
  },
};

// Initialize Shiki highlighter with supported languages
const highlighter = await createHighlighter({
  themes: [THEME],
  langs: [
    "css",
    "diff",
    "elixir",
    "elm",
    "html",
    "ini",
    "javascript",
    "json",
    "kotlin",
    "ruby",
    "typescript",
    "shell",
  ],
});

/**
 * Recursively finds all files with a given extension in a directory.
 * @param {string} dir - Directory to search
 * @param {string} ext - File extension to match (e.g., ".html")
 * @returns {Promise<string[]>} Array of absolute file paths
 */
async function findFiles(dir, ext) {
  const files = [];
  const entries = await readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await findFiles(fullPath, ext)));
    } else if (entry.name.endsWith(ext)) {
      files.push(fullPath);
    }
  }
  return files;
}

/**
 * Transforms Zola's footnote markup into accessible HTML structure (regex-based).
 *
 * @param {string} html - HTML string to process
 * @returns {string} HTML with transformed footnotes
 */
function processFootnotes(html) {
  // Update footnote references: <sup><a href="#1">1</a></sup> -> <sup id="fnref:1"><a href="#fn:1">1</a></sup>
  html = html.replace(
    /<sup><a href="#(\d+)">(\d+)<\/a><\/sup>/g,
    '<sup id="fnref:$1"><a href="#fn:$1">$2</a></sup>',
  );

  // Collect and transform footnote definitions
  const footnotes = [];
  const fnRegex = /<div id="(\d+)"><sup>\d+<\/sup>([\s\S]*?)<\/div>/g;
  let match;

  while ((match = fnRegex.exec(html)) !== null) {
    const id = match[1];
    let content = match[2];

    // Add back-link to the last paragraph or at the end
    if (content.includes("</p>")) {
      content = content.replace(
        /<\/p>(?![\s\S]*<\/p>)/,
        `&nbsp;<a href="#fnref:${id}" role="doc-backlink">↩</a></p>`,
      );
    } else {
      content += `<a href="#fnref:${id}" role="doc-backlink">↩</a>`;
    }

    footnotes.push({ id, content, original: match[0] });
  }

  if (footnotes.length === 0) return html;

  // Remove original footnote divs
  for (const fn of footnotes) {
    html = html.replace(fn.original, "");
  }

  // Build footnotes list
  const listItems = footnotes
    .map((fn) => `<li id="fn:${fn.id}">${fn.content}</li>`)
    .join("");
  const footnotesHtml = `<ol role="doc-endnotes">${listItems}</ol>`;

  // Insert before </section> or </article> or </body>
  if (html.includes("</section>")) {
    html = html.replace("</section>", `${footnotesHtml}</section>`);
  } else if (html.includes("</article>")) {
    html = html.replace("</article>", `${footnotesHtml}</article>`);
  } else {
    html = html.replace("</body>", `${footnotesHtml}</body>`);
  }

  return html;
}

/**
 * Processes markdown abbreviation definitions and wraps matching text in <abbr> tags (regex-based).
 *
 * @param {string} html - HTML string to process
 * @returns {string} HTML with abbreviations wrapped in <abbr> tags
 */
function processAbbreviations(html) {
  const abbreviations = {};

  // Extract abbreviation definitions from paragraphs and remove them
  html = html.replace(/<p>\s*\*\[([^\]]+)\]:\s*(.+?)\s*<\/p>/g, (match, abbr, title) => {
    abbreviations[abbr] = title.trim();
    return ""; // Remove the definition paragraph
  });

  if (Object.keys(abbreviations).length === 0) return html;

  // Replace abbreviations in text, but not inside code, pre, script, style, or abbr tags
  // Split HTML into parts: tags we skip, and everything else
  const skipTags = /<(code|pre|script|style|abbr)[^>]*>[\s\S]*?<\/\1>/gi;
  const parts = [];
  let lastIndex = 0;
  let match;

  while ((match = skipTags.exec(html)) !== null) {
    // Text before this tag (process it)
    if (match.index > lastIndex) {
      parts.push({ text: html.slice(lastIndex, match.index), process: true });
    }
    // The tag itself (don't process)
    parts.push({ text: match[0], process: false });
    lastIndex = skipTags.lastIndex;
  }
  // Remaining text after last tag
  if (lastIndex < html.length) {
    parts.push({ text: html.slice(lastIndex), process: true });
  }

  // Process parts and replace abbreviations
  for (const part of parts) {
    if (part.process) {
      for (const [abbr, title] of Object.entries(abbreviations)) {
        const escapedAbbr = abbr.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        // Only replace in text content (not inside tags)
        part.text = part.text.replace(
          new RegExp(`(>|^)([^<]*?)\\b${escapedAbbr}\\b`, "g"),
          (m, before, text) =>
            before + text.replace(new RegExp(`\\b${escapedAbbr}\\b`, "g"), `<abbr title="${title}">${abbr}</abbr>`),
        );
      }
    }
  }

  return parts.map((p) => p.text).join("");
}

/**
 * Decodes HTML entities in a string.
 * @param {string} text - Text with HTML entities
 * @returns {string} Decoded text
 */
function decodeHtmlEntities(text) {
  return text
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'");
}

/**
 * Applies syntax highlighting to code blocks using Shiki (regex-based).
 *
 * @param {string} html - HTML string to process
 * @returns {string} HTML with highlighted code blocks
 */
function convertCode(html) {
  // Handle block code: <pre><code class="..." data-lang="...">content</code></pre>
  html = html.replace(
    /<pre><code(?:\s+class="([^"]*)")?(?:\s+data-lang="([^"]*)")?[^>]*>([\s\S]*?)<\/code><\/pre>/g,
    (match, cls, dataLang, content) => {
      const lang = dataLang
        ? dataLang
        : cls
          ? cls.replace("language-", "").trim()
          : "text";

      const decoded = decodeHtmlEntities(content);

      // Skip Shiki for plain text
      if (lang === "text") {
        return `<pre><code>${content}</code></pre>`;
      }

      const highlighted = highlighter.codeToHtml(decoded, {
        lang,
        theme: THEME,
        transformers: [classTransformer],
      });

      // Unwrap Shiki's pre and return just the inner content in our pre
      const inner = highlighted.replace(/^<pre[^>]*>/, "").replace(/<\/pre>$/, "");
      return `<pre>${inner}</pre>`;
    },
  );

  return html;
}

/**
 * Cleans up empty and unnecessary span elements (regex-based).
 *
 * @param {string} html - HTML string to process
 * @returns {string} Cleaned HTML
 */
function cleanupSpans(html) {
  // Remove empty spans
  html = html.replace(/<span[^>]*><\/span>/g, "");

  // Remove spans without class or style (keep content)
  html = html.replace(/<span>([^<]*)<\/span>/g, "$1");

  // Remove whitespace-only spans (keep the whitespace)
  html = html.replace(/<span[^>]*>(\s+)<\/span>/g, "$1");

  return html;
}

/**
 * Merges adjacent spans with the same class (regex-based).
 *
 * @param {string} html - HTML string to process
 * @returns {string} HTML with merged spans
 */
function mergeSpans(html) {
  const regex =
    /<span class="([a-z]+)">([^<]*)<\/span>(\s*)<span class="\1">/gm;
  return html
    .replace(regex, '<span class="$1">$2$3')
    .replace(regex, '<span class="$1">$2$3');
}

/**
 * Converts a number to a class name (0=a, 25=z, 26=aa, etc.)
 * @param {number} n - Number to convert
 * @returns {string} Class name
 */
function toClassName(n) {
  let name = "";
  do {
    name = String.fromCharCode(97 + (n % 26)) + name;
    n = Math.floor(n / 26) - 1;
  } while (n >= 0);
  return name;
}

/**
 * Minifies class names to single/double letters using regex (no Cheerio).
 * Updates both element class attributes and CSS selectors.
 *
 * @param {string} html - HTML string to process
 * @returns {string} HTML with minified class names
 */
function minifyClassNames(html) {
  const classMap = {};
  let counter = 0;

  // First pass: find all classes and build the map, while replacing
  html = html.replace(/\bclass="([^"]+)"/g, (match, classes) => {
    const newClasses = classes
      .split(/\s+/)
      .map((cls) => {
        if (!cls) return cls;
        if (!classMap[cls]) classMap[cls] = toClassName(counter++);
        return classMap[cls];
      })
      .join(" ");
    return `class="${newClasses}"`;
  });

  // Second pass: replace class names in CSS selectors
  html = html.replace(/<style>([\s\S]*?)<\/style>/g, (match, css) => {
    const newCss = css.replace(/\.([a-z0-9_-]+)/gi, (m, cls) =>
      classMap[cls] ? `.${classMap[cls]}` : m,
    );
    return `<style>${newCss}</style>`;
  });

  return html;
}

// Shared PurgeCSS instance
const purgeCss = new PurgeCSS();

// Timing stats for processHtml steps (cumulative across all files)
const stats = {
  transforms: 0,
  shiki: 0,
  cleanupSpans: 0,
  combineCss: 0,
  purgeCss: 0,
  minifyClasses: 0,
  minifyHtml: 0,
};

/**
 * Processes a single HTML file through all optimization steps.
 *
 * @param {string} filePath - Absolute path to the HTML file
 * @param {string} baseCss - Pre-loaded CSS content to inline
 */
async function processHtml(filePath, baseCss) {
  let html = await readFile(filePath, "utf-8");

  // Step 1: Text transforms (regex-based)
  let t = performance.now();
  html = processFootnotes(html);
  html = processAbbreviations(html);
  stats.transforms += performance.now() - t;

  // Step 2: Syntax highlighting (Shiki)
  t = performance.now();
  html = convertCode(html);
  stats.shiki += performance.now() - t;

  // Step 3: Clean up spans
  t = performance.now();
  html = cleanupSpans(html);
  stats.cleanupSpans += performance.now() - t;

  // Step 4: Combine CSS (regex-based)
  t = performance.now();
  // Remove stylesheet links
  html = html.replace(/<link[^>]*rel="stylesheet"[^>]*>/g, "");
  // Collect and remove existing style tags
  let generatedCss = "";
  html = html.replace(/<style>([\s\S]*?)<\/style>/g, (match, css) => {
    generatedCss += css;
    return "";
  });
  // Insert combined CSS into head
  const allCss = `<style>${baseCss}${shikiCss}${generatedCss}</style>`;
  html = html.replace("</head>", `${allCss}</head>`);
  stats.combineCss += performance.now() - t;

  // Step 5: Per-page CSS purging (remove unused selectors)
  t = performance.now();
  const styleMatch = html.match(/<style>([\s\S]*?)<\/style>/);
  if (styleMatch) {
    const css = styleMatch[1];
    // Exclude style content from analysis to avoid false positives
    const htmlWithoutStyle = html.replace(/<style>[\s\S]*?<\/style>/g, "");
    const purged = await purgeCss.purge({
      content: [{ raw: htmlWithoutStyle, extension: "html" }],
      css: [{ raw: css }],
    });
    if (purged[0]?.css) {
      // Minify CSS after purging
      const minifiedCss = minifyCss(purged[0].css).css;
      html = html.replace(styleMatch[0], `<style>${minifiedCss}</style>`);
    }
  }
  stats.purgeCss += performance.now() - t;

  // Step 6: Minify class names and merge spans
  t = performance.now();
  html = minifyClassNames(html);
  html = mergeSpans(html);
  stats.minifyClasses += performance.now() - t;

  // Step 7: Final HTML minification
  t = performance.now();
  const minified = await minifyHtml(html, {
    collapseWhitespace: true,
    removeComments: true,
    removeEmptyAttributes: true,
    removeAttributeQuotes: true,
    removeOptionalTags: true,
  });
  stats.minifyHtml += performance.now() - t;

  await writeFile(filePath, minified);
}

/**
 * Logs elapsed time since a start timestamp.
 * @param {string} label - Description of the timed operation
 * @param {number} start - Start timestamp from performance.now()
 */
function logTime(label, start) {
  const ms = performance.now() - start;
  const display = ms < 10 ? `${ms.toFixed(2)}ms` : `${(ms / 1000).toFixed(2)}s`;
  console.log(`  ${label}: ${display}`);
}

/**
 * Main build function.
 * Processes all HTML and CSS files in the source directory.
 */
async function build() {
  const start = performance.now();
  const sourceDir = join(ROOT, SOURCE);

  // Load all CSS files into memory
  let stepStart = performance.now();
  const cssFiles = await findFiles(sourceDir, ".css");
  const cssContents = await Promise.all(
    cssFiles.map((file) => readFile(file, "utf-8")),
  );
  const baseCss = cssContents.join("");
  logTime("Load CSS", stepStart);

  // Process each HTML file
  stepStart = performance.now();
  const htmlFiles = await findFiles(sourceDir, ".html");
  console.log(`Processing ${htmlFiles.length} HTML files...`);
  await Promise.all(htmlFiles.map((file) => processHtml(file, baseCss)));
  logTime("Process HTML", stepStart);

  // Clean up CSS files (now inlined)
  stepStart = performance.now();
  await Promise.all(cssFiles.map(unlink));
  logTime("Clean up CSS", stepStart);

  // Log per-step timing breakdown
  console.log("Per-step breakdown (cumulative across all files):");
  for (const [step, ms] of Object.entries(stats)) {
    const display = ms < 10 ? `${ms.toFixed(2)}ms` : `${(ms / 1000).toFixed(2)}s`;
    console.log(`  ${step}: ${display}`);
  }

  const elapsed = ((performance.now() - start) / 1000).toFixed(2);
  console.log(`Build complete in ${elapsed}s`);
}

// Run build
build().catch((err) => {
  console.error(err);
  process.exit(1);
});
