/**
 * Build script for brianvanburken.nl
 *
 * This script post-processes the static HTML files generated by Zola.
 * It performs the following optimizations:
 *
 * 1. Syntax highlighting - Converts code blocks to highlighted HTML using Shiki
 * 2. Footnote processing - Transforms Zola's footnote markup to accessible HTML
 * 3. Abbreviation processing - Expands markdown abbreviations to <abbr> tags
 * 4. CSS inlining - Inlines external stylesheets into <style> tags
 * 5. CSS purging - Removes unused CSS rules per-page using PurgeCSS
 * 6. Class name minification - Shortens class names (e.g., "shiki_0_1" -> "a")
 * 7. HTML minification - Removes optional tags, whitespace, and comments
 *
 * Usage: node build.js
 * Environment: BUILD_DIR can override the default "public" directory
 */

import { readFile, writeFile, readdir, unlink } from "node:fs/promises";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { load } from "cheerio";
import { minify as minifyCss } from "csso";
import { PurgeCSS } from "purgecss";
import { minify as minifyHtml } from "html-minifier-terser";
import { createHighlighter } from "shiki";

const SOURCE = process.env.BUILD_DIR || "public";
const ROOT = dirname(fileURLToPath(import.meta.url));
const THEME = "ayu-dark";

// Initialize Shiki highlighter with supported languages
const highlighter = await createHighlighter({
  themes: [THEME],
  langs: [
    "css",
    "diff",
    "elixir",
    "elm",
    "html",
    "ini",
    "javascript",
    "json",
    "kotlin",
    "ruby",
    "typescript",
    "shell",
  ],
});

/**
 * Recursively finds all files with a given extension in a directory.
 * @param {string} dir - Directory to search
 * @param {string} ext - File extension to match (e.g., ".html")
 * @returns {Promise<string[]>} Array of absolute file paths
 */
async function findFiles(dir, ext) {
  const files = [];
  const entries = await readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await findFiles(fullPath, ext)));
    } else if (entry.name.endsWith(ext)) {
      files.push(fullPath);
    }
  }
  return files;
}

/**
 * Transforms Zola's footnote markup into accessible HTML structure.
 *
 * Zola outputs footnotes as:
 *   <sup><a href="#1">1</a></sup> ... <div id="1"><sup>1</sup><p>Text</p></div>
 *
 * This transforms them to:
 *   <sup id="fnref:1"><a href="#fn:1">1</a></sup> ... <ol role="doc-endnotes"><li id="fn:1"><p>Text <a href="#fnref:1">↩</a></p></li></ol>
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 */
function processFootnotes($) {
  // Update footnote references with proper IDs and hrefs
  $("sup > a[href^='#']").each(function () {
    const $link = $(this);
    const href = $link.attr("href");
    const match = href.match(/^#(\d+)$/);
    if (match) {
      const fnId = match[1];
      const $sup = $link.parent();
      $sup.attr("id", `fnref:${fnId}`);
      $link.attr("href", `#fn:${fnId}`);
    }
  });

  // Collect footnote definition divs
  const footnoteDivs = [];
  $("div[id]").each(function () {
    const $div = $(this);
    const id = $div.attr("id");
    if (/^\d+$/.test(id)) {
      footnoteDivs.push({ id, $div });
    }
  });

  if (footnoteDivs.length === 0) return;

  // Create accessible footnotes list
  const $ol = $('<ol role="doc-endnotes"></ol>');

  footnoteDivs.forEach(({ id, $div }) => {
    // Remove the redundant <sup>N</sup> number
    $div.find("sup").first().remove();

    // Add back-link to the last paragraph
    const $lastP = $div.find("p").last();
    if ($lastP.length) {
      $lastP.append(`&nbsp;<a href="#fnref:${id}" role="doc-backlink">↩</a>`);
    } else {
      $div.append(`<a href="#fnref:${id}" role="doc-backlink">↩</a>`);
    }

    // Move content to list item
    const $li = $(`<li id="fn:${id}"></li>`);
    $li.append($div.contents());
    $ol.append($li);
    $div.remove();
  });

  // Append footnotes to article or body
  const $article = $("article");
  if ($article.length) {
    $article.find("section").append($ol);
  } else {
    $("body").append($ol);
  }
}

/**
 * Processes markdown abbreviation definitions and wraps matching text in <abbr> tags.
 *
 * Abbreviation syntax: *[ABBR]: Full expansion text
 *
 * Example:
 *   *[HTML]: HyperText Markup Language
 *   The HTML specification...
 *
 * Becomes:
 *   The <abbr title="HyperText Markup Language">HTML</abbr> specification...
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 */
function processAbbreviations($) {
  const abbreviations = {};
  const abbrRegex = /\*\[([^\]]+)\]:\s*(.+)/g;

  // Extract abbreviation definitions from paragraphs
  $("p").each(function () {
    const text = $(this).text();
    let match;
    let hasAbbr = false;

    while ((match = abbrRegex.exec(text)) !== null) {
      abbreviations[match[1]] = match[2].trim();
      hasAbbr = true;
    }
    abbrRegex.lastIndex = 0;

    // Remove paragraph if it only contained abbreviation definitions
    if (hasAbbr) {
      const cleanedText = text.replace(/\*\[[^\]]+\]:\s*.+/g, "").trim();
      if (cleanedText === "") {
        $(this).remove();
      }
    }
  });

  if (Object.keys(abbreviations).length === 0) return;

  // Replace abbreviations in text nodes (excluding code, pre, script, style, abbr)
  const replaceInText = (node) => {
    if (node.type === "text" && node.data) {
      let text = node.data;
      for (const [abbr, title] of Object.entries(abbreviations)) {
        const escapedAbbr = abbr.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const regex = new RegExp(`\\b${escapedAbbr}\\b`, "g");
        text = text.replace(regex, `<abbr title="${title}">${abbr}</abbr>`);
      }
      if (text !== node.data) {
        $(node).replaceWith(text);
      }
    }
  };

  $("body *")
    .not("code, pre, script, style, abbr")
    .contents()
    .each(function () {
      replaceInText(this);
    });
}

/**
 * Applies syntax highlighting to code blocks using Shiki.
 *
 * This function:
 * 1. Highlights code blocks with Shiki (generates inline styles)
 * 2. Converts inline styles to CSS classes (reduces HTML size)
 * 3. Removes default/unnecessary classes (theme defaults)
 * 4. Cleans up nested and empty span tags
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 */
function convertCode($) {
  // Theme default styles to remove (already set in base CSS)
  const DEFAULT_COLOR_KEY = "COLOR:#BFBDB6";
  const ITALIC_KEY = "FONT-STYLE:ITALIC";
  const BG_KEY = "BACKGROUND-COLOR:#0B0E14";

  let css = "";
  const cssMap = {}; // Maps style declarations to class names

  // Highlight all code blocks
  $("code").each(function () {
    const $code = $(this);
    const $parent = $code.parent();
    const isInlineCode = $parent[0].name !== "pre";

    // Determine language from class or data-lang attribute
    const cls = $code.attr("class");
    const dataLang = $code.attr("data-lang");
    const lang = dataLang
      ? dataLang
      : cls
        ? cls.toString().replace("language-", "").trim()
        : "text";

    const content = $code.text();
    const highlighted = highlighter.codeToHtml(content, { lang, theme: THEME });

    if (isInlineCode) {
      $code.attr("style", $(highlighted).attr("style"));
    } else {
      $parent.replaceWith(`<pre>${highlighted}</pre>`);
    }
  });

  // Convert inline styles to CSS classes for smaller output
  let index = 0;
  $("*[style]").each(function () {
    const styleContent = $(this).attr("style").trim();
    const styles = styleContent.split(";");

    for (let i = 0; i < styles.length; i++) {
      const styleKey = styles[i].replace(/[\s;]/g, "").toUpperCase();
      if (!styleKey) continue;

      // Reuse existing class or create new one
      const className = cssMap[styleKey] || `s${index}_${i}`;
      if (!cssMap[styleKey]) {
        css += `.${className}{${styles[i]}}\n`;
        cssMap[styleKey] = className;
      }

      $(this).addClass(className);
    }
    $(this).removeAttr("style");
    index++;
  });

  if (css) {
    $("body").append(`<style>${css}</style>`);
  }

  // Remove classes for default theme styles (already in base CSS)
  for (const key of [DEFAULT_COLOR_KEY, ITALIC_KEY, BG_KEY]) {
    const cls = cssMap[key];
    if (cls) $(`.${cls}`).removeClass(cls);
  }

  // Clean up nested pre tags (Shiki wraps output in pre)
  $("pre > pre").each(function () {
    $(this).parent().replaceWith($(this).parent().html());
  });

  // Clean up empty and wrapper spans
  $("span:empty").remove();
  $("span > span:first-child").each(function () {
    $(this).parent().replaceWith($(this).parent().html());
  });
  $("span").each(function () {
    const content = $(this).text();
    // Remove spans that only contain whitespace
    if (content.trim() === "") {
      $(this).replaceWith(content);
    }
    // Remove spans without class or style
    if (!$(this).attr("class") && !$(this).attr("style")) {
      $(this).replaceWith($(this).html());
    }
  });
}

/**
 * Merges adjacent span elements with the same class.
 *
 * Example:
 *   <span class="a">foo</span> <span class="a">bar</span>
 * Becomes:
 *   <span class="a">foo bar</span>
 *
 * @param {string} html - HTML string to process
 * @returns {string} HTML with merged spans
 */
function mergeSpans(html) {
  const regex =
    /<span class="([a-z0-9_]+)">([^<]*)<\/span>(\s*)<span class="\1">/gm;
  // Run twice to catch consecutive matches
  return html
    .replace(regex, '<span class="$1">$2$3')
    .replace(regex, '<span class="$1">$2$3');
}

/**
 * Removes CSS rules for classes that are not used in the document.
 * Only processes class-based rules (e.g., .s0_1{...}).
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 */
function removeUnusedCss($) {
  const usedClasses = new Set();

  // Collect all classes used in the document
  $("[class]").each(function () {
    const classes = $(this).attr("class").split(/\s+/);
    classes.forEach((c) => usedClasses.add(c));
  });

  // Filter style tag content
  $("style").each(function () {
    const css = $(this).html();
    const filteredCss = css
      .split("\n")
      .filter((rule) => {
        const classMatch = rule.match(/^\.([a-z0-9_]+)\{/);
        return !classMatch || usedClasses.has(classMatch[1]);
      })
      .join("");
    $(this).html(filteredCss);
  });
}

/**
 * Inlines external CSS files referenced by <link> tags.
 * Replaces <link rel="stylesheet" href="..."> with <style>...</style>
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 * @param {string} baseDir - Base directory for resolving relative paths
 */
async function inlineCss($, baseDir) {
  const links = $('link[rel="stylesheet"]');
  for (let i = 0; i < links.length; i++) {
    const $link = $(links[i]);
    const href = $link.attr("href");
    if (href && !href.startsWith("http")) {
      const cssPath = join(baseDir, href);
      try {
        const css = await readFile(cssPath, "utf-8");
        $link.replaceWith(`<style>${css}</style>`);
      } catch {
        // File not found, leave link as-is
      }
    }
  }
}

/**
 * Minifies class names to single/double letters (a, b, ..., z, aa, ab, ...).
 * Updates both element class attributes and CSS selectors.
 *
 * @param {import('cheerio').CheerioAPI} $ - Cheerio instance
 */
function minifyClassNames($) {
  const classMap = {};
  let counter = 0;

  /**
   * Converts a number to a class name (0=a, 25=z, 26=aa, etc.)
   * @param {number} n - Number to convert
   * @returns {string} Class name
   */
  const toClassName = (n) => {
    let name = "";
    do {
      name = String.fromCharCode(97 + (n % 26)) + name;
      n = Math.floor(n / 26) - 1;
    } while (n >= 0);
    return name;
  };

  // Build mapping of original -> minified class names
  $("[class]").each(function () {
    const classes = $(this).attr("class").split(/\s+/);
    for (const cls of classes) {
      if (cls && !classMap[cls]) {
        classMap[cls] = toClassName(counter++);
      }
    }
  });

  // Update element class attributes
  $("[class]").each(function () {
    const classes = $(this).attr("class").split(/\s+/);
    const newClasses = classes.map((c) => classMap[c] || c).join(" ");
    $(this).attr("class", newClasses);
  });

  // Update CSS selectors in style tags
  $("style").each(function () {
    let css = $(this).html();
    for (const [oldClass, newClass] of Object.entries(classMap)) {
      css = css.replace(new RegExp(`\\.${oldClass}\\b`, "g"), `.${newClass}`);
    }
    $(this).html(css);
  });
}

/**
 * Processes a single HTML file through all optimization steps.
 *
 * @param {string} filePath - Absolute path to the HTML file
 */
async function processHtml(filePath) {
  let content = await readFile(filePath, "utf-8");
  let $ = load(content);

  // Step 1: Custom transforms (footnotes, abbreviations, syntax highlighting)
  processFootnotes($);
  processAbbreviations($);
  convertCode($);

  // Step 2: Clean up Shiki output
  content = mergeSpans($.html());
  $ = load(content);
  removeUnusedCss($);

  // Step 3: Inline external CSS
  await inlineCss($, join(ROOT, SOURCE));

  // Step 4: Merge all style tags into one in <head>
  const allCss = $("style")
    .map(function () {
      return $(this).html();
    })
    .get()
    .join("");
  $("style").remove();
  if (allCss) {
    $("head").append(`<style>${allCss}</style>`);
  }

  // Step 5: Per-page CSS purging (remove unused selectors)
  let html = $.html();
  const styleMatch = html.match(/<style>([\s\S]*?)<\/style>/);
  if (styleMatch) {
    const css = styleMatch[1];
    // Exclude style content from analysis to avoid false positives
    const htmlWithoutStyle = html.replace(/<style>[\s\S]*?<\/style>/g, "");
    const purged = await new PurgeCSS().purge({
      content: [{ raw: htmlWithoutStyle, extension: "html" }],
      css: [{ raw: css }],
    });
    if (purged[0]?.css) {
      html = html.replace(styleMatch[0], `<style>${purged[0].css}</style>`);
    }
  }

  // Step 6: Minify class names
  $ = load(html);
  minifyClassNames($);

  // Step 7: Final HTML minification
  const minified = await minifyHtml($.html(), {
    collapseWhitespace: true,
    removeComments: true,
    removeEmptyAttributes: true,
    removeAttributeQuotes: true,
    removeOptionalTags: true,
  });

  await writeFile(filePath, minified);
}

/**
 * Minifies all CSS files in the source directory.
 * This runs before HTML processing so inlined CSS is already minified.
 */
async function processCss() {
  const sourceDir = join(ROOT, SOURCE);
  const cssFiles = await findFiles(sourceDir, ".css");

  for (const cssFile of cssFiles) {
    const css = await readFile(cssFile, "utf-8");
    const minified = minifyCss(css).css;
    await writeFile(cssFile, minified);
  }
}

/**
 * Deletes all CSS files in the source directory.
 * Called after HTML processing since CSS is now inlined.
 */
async function cleanCss() {
  const sourceDir = join(ROOT, SOURCE);
  const cssFiles = await findFiles(sourceDir, ".css");
  for (const file of cssFiles) {
    await unlink(file);
  }
}

/**
 * Main build function.
 * Processes all HTML and CSS files in the source directory.
 */
async function build() {
  const start = performance.now();
  const sourceDir = join(ROOT, SOURCE);
  const htmlFiles = await findFiles(sourceDir, ".html");

  console.log(`Processing ${htmlFiles.length} HTML files...`);

  // Minify CSS files first (before inlining)
  await processCss();

  // Process each HTML file
  for (const file of htmlFiles) {
    await processHtml(file);
  }

  // Clean up CSS files (now inlined)
  await cleanCss();

  const elapsed = ((performance.now() - start) / 1000).toFixed(2);
  console.log(`Build complete in ${elapsed}s`);
}

// Run build
build().catch((err) => {
  console.error(err);
  process.exit(1);
});
