<!DOCTYPE html><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="data:,"><style>html{background:#0b0e14;color:#fff}body{font-family:Avenir Next,Open Sans,Helvetica,sans-serif;font-size:1.125rem;margin:1.5rem auto;max-width:70ch;padding:0 1.5rem}article,code,footer,h1,h2,ol,p,pre{line-height:1.5rem;margin:1.5rem 0}h1{font-size:2.5rem;line-height:3rem}ol{padding-left:1.5rem}p{text-align:justify}img{max-width:100%}h2{margin-top:3rem}a,a code{color:#fa3}a:visited{color:#ff9500}a:focus,a:hover{color:#ffbf66}footer{border-top:1px solid #bfbdb6;padding-top:1.5rem}code,pre{font-size:.875rem;word-break:normal;word-spacing:normal;word-wrap:normal;background:#0b0e14;border-radius:.375rem;color:#bfbdb6;hyphens:none}pre{overflow:auto;padding:1.5rem}li code,p code{line-height:1;margin:0 2px;outline:3px solid #0b0e14}@media (prefers-color-scheme:light){html{background:#fff;color:#0b0e14}}.f{color:#59c2ff}.e{color:#bfbdb6b3}.g{color:#ffb454}.h{color:#aad94c}.d{color:#f29668}.c{color:#ff8f40}</style><link type="application/atom+xml" rel="alternate" href="https://brianvanburken.nl/feed.xml" title="Brian van Burken"><title>Maybe Don’t Use Maybe? | Brian van Burken</title><meta name="generator" content="Jekyll v4.4.1"><meta property="og:title" content="Maybe Don’t Use Maybe?"><meta property="og:locale" content="en_US"><meta name="description" content="Your code could be littered with branches that result in invalid data and should never happen, but are allowed. We found such a case, at my work, where we allowed multiple variants of data, and it broke our code logic. We use Elm and fixed it using its type system. Although we describe the solution for Elm in this blog, the cases and fixes also apply to other similar languages like Haskell and PureScript. In this blog post we find the seemly impossible bug using examples written in Elm and go through a step by step progress to fix it. At the end, you could find similar cases in your application and know a way to fix them. Before we go fix our bug let’s get clear on the domain model."><meta property="og:description" content="Your code could be littered with branches that result in invalid data and should never happen, but are allowed. We found such a case, at my work, where we allowed multiple variants of data, and it broke our code logic. We use Elm and fixed it using its type system. Although we describe the solution for Elm in this blog, the cases and fixes also apply to other similar languages like Haskell and PureScript. In this blog post we find the seemly impossible bug using examples written in Elm and go through a step by step progress to fix it. At the end, you could find similar cases in your application and know a way to fix them. Before we go fix our bug let’s get clear on the domain model."><link rel="canonical" href="https://brianvanburken.nl/maybe-dont-use-maybe/"><meta property="og:url" content="https://brianvanburken.nl/maybe-dont-use-maybe/"><meta property="og:site_name" content="Brian van Burken"><meta property="og:type" content="article"><meta property="article:published_time" content="2018-08-13T00:00:00+00:00"><meta name="twitter:card" content="summary"><meta property="twitter:title" content="Maybe Don’t Use Maybe?"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-10-30T15:07:32+00:00","datePublished":"2018-08-13T00:00:00+00:00","description":"Your code could be littered with branches that result in invalid data and should never happen, but are allowed. We found such a case, at my work, where we allowed multiple variants of data, and it broke our code logic. We use Elm and fixed it using its type system. Although we describe the solution for Elm in this blog, the cases and fixes also apply to other similar languages like Haskell and PureScript. In this blog post we find the seemly impossible bug using examples written in Elm and go through a step by step progress to fix it. At the end, you could find similar cases in your application and know a way to fix them. Before we go fix our bug let’s get clear on the domain model.","headline":"Maybe Don’t Use Maybe?","mainEntityOfPage":{"@type":"WebPage","@id":"https://brianvanburken.nl/maybe-dont-use-maybe/"},"url":"https://brianvanburken.nl/maybe-dont-use-maybe/"}</script><p><a href="/" title="Overview of all my writings">Writings</a> | <a href="https://github.com/brianvanburken" title="Visit my GitHub profile" target="_blank" rel="noopener noreferrer">GitHub</a> | <a href="https://linkedin.com/in/brianvanburken" title="Visit my LinkedIn profile" target="_blank" rel="noopener noreferrer">LinkedIn</a><article itemscope itemtype="http://schema.org/BlogPosting"><h1 itemprop="name headline">Maybe Don't Use Maybe?</h1><section itemprop="articleBody"><p>Your code could be littered with branches that result in invalid data and should never happen, but are allowed. We found such a case, at my work, where we allowed multiple variants of data, and it broke our code logic. We use <a href="http://elm-lang.org/" target="_blank" rel="noopener noreferrer">Elm</a> and fixed it using its type system. Although we describe the solution for Elm in this blog, the cases and fixes also apply to other similar languages like <a href="https://www.haskell.org/" target="_blank" rel="noopener noreferrer">Haskell</a> and <a href="http://www.purescript.org/" target="_blank" rel="noopener noreferrer">PureScript</a>. In this blog post we find the seemly impossible bug using examples written in Elm and go through a step by step progress to fix it. At the end, you could find similar cases in your application and know a way to fix them. Before we go fix our bug let’s get clear on the domain model.<h2 id="how-did-we-get-here">How did we get here?</h2><p>Our domain contains the model “Question” which can have exactly one “Answer” or is not answered yet. If the question has been answered then we receive the timestamp and content of the answer. This all will be sent by an API using JSON. Note: for this post, I’ve simplified our domain to this specific case.<p>Our back-end was built separate from the front-end and one of the decisions of the back-end team was to send out both fields on the root level of the JSON document. These fields will always be present and, when there is no answer yet, default to <code>null</code>.<p>Our domain code started out like this:<pre tabindex="0"><code><span class="c">type alias Question</span><span class="d"> =</span>
    { id: <span class="c">String</span>
<span class="e">    ,</span><span class="f"> date</span><span class="c"> : Date</span>
<span class="e">    ,</span> content: <span class="c">String</span>
<span class="e">    ,</span> answer: <span class="c">Answer</span>
    }

<span class="c">type Answer</span><span class="d"> =</span> Answer (<span class="c">Maybe String</span>) (<span class="c">Maybe Date</span>)
</code></pre><p>Here we store both fields on the question at the same level as we received from the back-end. And our decoder looked like this:<pre tabindex="0"><code><span class="c">import</span> Json<span class="c">.</span>Decode <span class="c">as</span> JD
<span class="c">import</span> DateTime  -- Note: DateTime contains our internal decoder for dates

<span class="g">decoder</span><span class="c"> :</span> JD<span class="c">.Decoder Question</span>
<span class="g">decoder</span><span class="c"> =</span>
    JD<span class="c">.</span>map4 Question
        (JD<span class="c">.</span>field <span class="h">"id"</span> JD<span class="c">.</span>string)
        (JD<span class="c">.</span>field <span class="h">"date"</span> DateTime<span class="c">.</span>decoder)
        (JD<span class="c">.</span>field <span class="h">"content"</span> JD<span class="c">.</span>string)
        (JD<span class="c">.</span>map2 Answer
            (JD<span class="c">.</span>field <span class="h">"answer"</span> (JD<span class="c">.</span>maybe JD<span class="c">.</span>string))
            (JD<span class="c">.</span>field <span class="h">"answeredOn"</span> (JD<span class="c">.</span>maybe DateTime<span class="c">.</span>decoder))
		)
</code></pre><h2 id="maybe-we-have-a-bug">Maybe we have a bug?</h2><p>If we look closer at our <code>Answer</code> type we see that it takes two <code>Maybe</code>’s. If we think about it in terms of <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types" target="_blank" rel="noopener noreferrer">algebraic data types</a> we can reason that this solution has four possible cases for our answer:<ol><li><code>Answer (Just _) (Just _)</code><li><code>Answer (Just _) Nothing</code><li><code>Answer Nothing (Just _)</code><li><code>Answer Nothing Nothing</code></ol><p>Are all these cases valid? If we revisit the domain logic then it becomes more clear: if there is an answer we receive both <code>answer</code> and <code>answeredOn</code> filled in, else we receive both fields with a null value. This means we have only two possible cases:<ol><li>we have an answer and both fields are filled in<li>we have no answer and both fields are empty</ol><p>This is not what we represent in our code. There are four possible cases right now! We only want the two cases that are valid and we can’t express that right now. This allowed for a bug to slip in where one of the fields for an answer was set to <code>null</code> and made our application show contradicting information to our users. Luckily for us, we can leverage Elm’s awesome type system to make the other cases impossible! Let’s improve our code.<h2 id="maybe-this-will-fix-it">Maybe this will fix it?</h2><p>We could wrap our <code>Answer</code> type in a <code>Maybe</code> and remove the <code>Maybe</code> for both the values or another approach is to expand our <code>Answer</code> type to a <a href="https://guide.elm-lang.org/types/custom_types.html" target="_blank" rel="noopener noreferrer">Custom Type</a> (also called Union Type). Before we refactor our code let’s think about how our code looks in each approach. Compare both examples below one of each possible fix and look at how we would use it rendering our answer. First look at the approach using <code>Maybe</code>:<pre tabindex="0"><code><span class="c">import</span> Html <span class="c">exposing</span> (<span class="c">Html</span>)

<span class="c">type Answer</span><span class="d"> =</span> Answer <span class="c">String Date

type alias Question</span><span class="d"> =</span>
    { id: <span class="c">String</span>
<span class="e">    ,</span><span class="f"> date</span><span class="c"> : Date</span>
<span class="e">    ,</span> content: <span class="c">String</span>
<span class="e">    ,</span> answer: <span class="c">Maybe Answer</span>
    }

<span class="g">viewAnswer</span><span class="c"> : Maybe Answer</span><span class="d"> -&gt;</span><span class="c"> Html Never</span>
<span class="g">viewAnswer</span> possibleAnswer <span class="c">=
    case </span>possibleAnswer <span class="c">of</span>
        Just (Answer content <span class="c">_</span>) <span class="d">-&gt;</span>
            Html<span class="c">.</span>text content

        Nothing <span class="d">-&gt;</span>
            Html<span class="c">.</span>text <span class="h">"No answer yet"</span>
</code></pre><p>And our Union type approach:<pre tabindex="0"><code><span class="c">import</span> Html <span class="c">exposing</span> (<span class="c">Html</span>)

<span class="c">type Answer</span>
<span class="d">    =</span> Answered <span class="c">String Date</span>
<span class="d">    |</span> NoAnswerYet


<span class="c">type alias Question</span><span class="d"> =</span>
    { id: <span class="c">String</span>
<span class="e">    ,</span><span class="f"> date</span><span class="c"> : Date</span>
<span class="e">    ,</span> content: <span class="c">String</span>
<span class="e">    ,</span> answer: <span class="c">Answer</span>
    }

<span class="g">viewAnswer</span><span class="c"> : Answer</span><span class="d"> -&gt;</span><span class="c"> Html Never</span>
<span class="g">viewAnswer</span> answer <span class="c">=
    case </span>answer <span class="c">of</span>
        Answered content <span class="c">_</span><span class="d"> -&gt;</span>
            Html<span class="c">.</span>text content

        NoAnswerYet <span class="d">-&gt;</span>
            Html<span class="c">.</span>text <span class="h">"No answer yet"</span>
</code></pre><p>As you can see our Union type approach is less code (you don’t have to write <code>Maybe</code> and <code>Just</code> for the value) and has more clarity. Using Maybe does fix it quickly. But, it adds an extra level of abstraction around our Answer type. Having to unwrap the Maybe first to get to our Answer type. With the Custom Type approach, it is clear that we have an answer or no answer, this shows more intent than a Maybe. Also, our code emits an uncertainty when using Maybe. A great talk about uncertainties in your Elm code can be watched here: <a href="https://youtu.be/43eM4kNbb6c" target="_blank" rel="noopener noreferrer">Working with Maybe</a> by Joël Quenneville. We don’t want any uncertainties in our code. We are certain that when decoded we either have an answer or have no answer.<p>On the downside, when going for the Custom Type approach, we do lose the possibility for using <code>Maybe.map</code> and have to use case for everything. This boils down to having the power of mapping or clarity of intent in our code. Since we, developers, read code more than we write (said by Robert C. Martin in his book Clean Code and by many others) it means that clarity of intent trumps power we decided to go with the Custom Type approach.<h2 id="making-the-seemly-impossible-impossible">Making the seemly impossible impossible</h2><p>First, we change our Answer type that represents our only two possible cases.<pre tabindex="0"><code><span class="c">type Answer</span>
<span class="d">    =</span> Answered <span class="c">String Date</span>
<span class="d">    |</span> NoAnswerYet
</code></pre><p>Then we change our decoder to set return the Answered type if all is well and <code>NoAnswerYet</code> for the other cases where one or more of the fields are <code>null</code>. To make our code more concise we use <a href="http://package.elm-lang.org/packages/elm-community/json-extra/2.7.0/Json-Decode-Extra#withDefault" target="_blank" rel="noopener noreferrer"><code>Json.Decode.Extra.withDefault</code></a> to set a fallback if one of our fields are <code>null</code>.<pre tabindex="0"><code><span class="c">import</span> Json<span class="c">.</span>Decode<span class="c">.</span>Extra <span class="c">as</span> JDE

<span class="g">decoder</span><span class="c"> :</span> JD<span class="c">.Decoder Question</span>
<span class="g">decoder</span><span class="c"> =</span>
    JD<span class="c">.</span>map4 Question
        (JD<span class="c">.</span>field <span class="h">"id"</span> JD<span class="c">.</span>string)
        (JD<span class="c">.</span>field <span class="h">"date"</span> DateTime<span class="c">.</span>decoder)
        (JD<span class="c">.</span>field <span class="h">"content"</span> JD<span class="c">.</span>string)
        (JD<span class="c">.</span>map2 Answered
            (JD<span class="c">.</span>field <span class="h">"answer"</span> JD<span class="c">.</span>string)
            (JD<span class="c">.</span>field <span class="h">"answeredOn"</span> DateTime<span class="c">.</span>decoder)
<span class="d">            |&gt;</span> JDE<span class="c">.</span>withDefault NoAnswerYet
        )
</code></pre><p>Now our code is safe from weird cases and is more expressive! Having fewer possible cases means fewer possible bugs, makes it easier to test, and easier to reason about what the code can do. Another small advantage is that you won’t have to write tests for the other weird cases. If you try to write such a test the compiler just won’t allow you. Thus, we don’t need to write any tests and save time. With this, we fixed our bug using the powerful Elm type system.<p>You can check out the final <abbr title="Short, Self Contained, Correct (Compilable), Example">SSCCE</abbr> here: <a href="https://ellie-app.com/PnhF7yzQtra1" target="_blank" rel="noopener noreferrer">https://ellie-app.com/PnhF7yzQtra1</a><p>If you are interested in learning more about fixing similar problems in your Elm application I highly recommend to watch <a href="https://youtu.be/IcgmSRJHu_8" target="_blank" rel="noopener noreferrer">Making Impossible States Impossible</a> by Richard Feldman.</section><footer>Published on <time datetime="2018-08-13T00:00:00+00:00" itemprop="datePublished">2018-08-13 </time><br>Tags: <a href="/tags/#custom-types" title="See all post for Custom Types">Custom Types</a>, <a href="/tags/#elm" title="See all post for Elm">Elm</a>, <a href="/tags/#maybe" title="See all post for Maybe">Maybe</a>, <a href="/tags/#monads" title="See all post for Monads">Monads</a><br>Source <a href="https://github.com/brianvanburken/brianvanburken.github.io/tree/master/_posts/2018-08-13-maybe-dont-use-maybe.md" target="_blank" rel="noopener noreferrer">on Github</a></footer></article><script data-goatcounter="https://brianvanburken.goatcounter.com/count" async src="https://gc.zgo.at/count.js"></script><noscript><img src="https://brianvanburken.goatcounter.com/count?p=/maybe-dont-use-maybe/"></noscript>