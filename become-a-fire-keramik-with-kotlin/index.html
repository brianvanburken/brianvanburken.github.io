<!DOCTYPE html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/atom+xml title="RSS Feed" href=https://brianvanburken.nl/feed.xml><title>Become a Fire Keramik with Kotlin | Brian van Burken</title><meta property=og:title content="Become a Fire Keramik with Kotlin"><meta name=description content="At my work we started using Kotlin more and more. I wondered how far you could go in writing fully Functional in the language."><meta property=og:description content="At my work we started using Kotlin more and more. I wondered how far you could go in writing fully Functional in the language."><meta property=og:type content=article><meta property=og:url content=https:&#x2F;&#x2F;brianvanburken.nl&#x2F;become-a-fire-keramik-with-kotlin&#x2F;><meta property=og:site_name content="Brian van Burken"><link rel=canonical href=https:&#x2F;&#x2F;brianvanburken.nl&#x2F;become-a-fire-keramik-with-kotlin&#x2F;><meta property=article:published_time content=2020-08-03T00:00:00+00:00><style>html{color:#fff;background:#0b0e14}@media (prefers-color-scheme:light){html{color:#0b0e14;background:#fff}}body{font-family:"Avenir Next","Open Sans",Helvetica,sans-serif;font-size:1.125rem;max-width:70ch;margin:1.5rem auto;padding:0 1.5rem}article,code,footer,h1,h2,p,pre,ul{margin:1.5rem 0;line-height:1.5rem}h1{font-size:2.5rem;line-height:3rem}ul{padding-left:1.5rem}p{text-align:justify}img{max-width:100%}h2{margin-top:3rem}a,a code{color:#fa3}a:visited{color:#ff9500}a:focus,a:hover{color:#ffbf66}footer{border-top:1px solid #bfbdb6;padding-top:1.5rem}code,pre{font-size:.875rem;word-spacing:normal;word-break:normal;word-wrap:normal;hyphens:none;color:#bfbdb6;background:#0b0e14;border-radius:.375rem}pre{overflow:auto;padding:1.5rem}li code,p code{line-height:1;outline:3px solid #0b0e14;margin:0 2px}.b{color:#ff8f40}.c{color:#59c2ff}.d{color:#bfbdb6}.e{color:#f29668}.h{color:#aad94c}.i{color:#5a6673}.f{color:#ffb454}.g{color:#d2a6ff}</style><p><a href=/ title="Overview of all my writings">Writings</a> | <a href=https://github.com/brianvanburken title="Visit my GitHub profile" target=_blank rel="noopener noreferrer">GitHub</a> | <a href=https://linkedin.com/in/brianvanburken title="Visit my LinkedIn profile" target=_blank rel="noopener noreferrer">LinkedIn</a><article itemscope itemtype=http://schema.org/BlogPosting><h1 itemprop="name headline">Become a Fire Keramik with Kotlin</h1><section itemprop=articleBody><p>I have noticed an interesting trend here at my work Avisi: an increasing number of teams are choosing Kotlin for their projects! Kotlin allows programmers to utilize more aspects of functional programming. This made me wonder, how far can you go with functional programming in Kotlin?<p>While searching for a definition of the basics of functional programming, I found an interesting PDF-file that was created by smart people from the functional programming community. The document is called "LambdaConf Standardised Ladder of Functional Programming" and you can <a href=/assets/become-a-fire-keramik-with-kotlin/lambdaconf_slfp.pdf>download it here</a> (sadly the original host of the file has disappeared). It breaks down various concepts and skills into levels. The first level is called "Fire Keramik", which inspired the title of this blog. There has been some <a rel="noopener nofollow noreferrer external" target=_blank href="https://news.ycombinator.com/item?id=13067741">criticism</a> about this list, but in my opinion, it's a good starting point and uses some of the fun of "skill trees" found in games. To become a "Fire Keramik", you need to learn the following concepts and skills:<p><strong>Concepts</strong><ul><li>Immutable data<li>Second-Order Functions<li>Constructing &amp; Destructuring<li>Function Composition<li>Higher-Order Functions &amp; Lambdas</ul><p><strong>Skills</strong><ul><li>Use second-order functions<li>Destructuring values to access their components<li>Use data-types to represent optionality<li>Read basic type signatures<li>Pass lambdas to second-order functions</ul><p>In this blog post, I will explore the possibilities of using all these concepts and skills in Kotlin. For the sake of brevity, I won't go into the details as to why you should apply it. Without further ado, let's get into the first concept!<h2 id=immutable-data>Immutable data</h2><p>Immutable data is data that cannot be changed after it has been initialized. To "change" immutable data, you have to create a copy of the data and apply your change in the process. Kotlin has a similar concept using <code>val</code> and <code>var</code>. <code>val</code> allows the programmer to mark a value as <code>read-only</code> after its initialization. You won't be able to override this in the code later and if you try to change its value, the compiler will throw an error at you. Kotlin won't enforce immutability, so the choice between <code>val</code> and <code>var</code> is up to the programmer.<pre><code><span class=a><span class=b>class</span><span class=c> Birthday</span><span class=d>(</span><span class=b>val</span><span class=d> day: </span><span class=c>Int</span><span class=d>, </span><span class=b>val</span><span class=d> month: </span><span class=c>Int</span><span class=d>, </span><span class=b>val</span><span class=d> year: </span><span class=c>Int</span><span class=d>)</span></span>

<span class=a><span class=b>class</span><span class=c> Person</span><span class=d>(</span><span class=b>val</span><span class=d> name: </span><span class=c>String</span><span class=d>, </span><span class=b>val</span><span class=d> age: </span><span class=c>Birthday</span><span class=d>)</span></span>


<span class=a><span class=b>val</span><span class=d> age </span><span class=e>=</span><span class=f> Birthday</span><span class=d>(</span><span class=g>1</span><span class=d>, </span><span class=g>1</span><span class=d>, </span><span class=g>1970</span><span class=d>)</span></span>
<span class=a><span class=b>val</span><span class=d> person </span><span class=e>=</span><span class=f> Person</span><span class=d>(</span><span class=h>"Nick"</span><span class=d>, age)</span></span>
<span class=a><span class=d>age.year </span><span class=e>=</span><span class=g> 2020</span><span class=i> // Throws an compiler error</span></span>
<span class=a><span class=d>person.age.year </span><span class=e>=</span><span class=g> 2020</span><span class=i> // Throws an compiler error</span></span>
</code></pre><h2 id=use-data-types-to-represent-optionality>Use data types to represent optionality</h2><p>In Java, optionality is represented by using <code>Optional</code>. This is similar to Haskell's <code>Maybe</code> type. You won't find these representations in Kotlin. Kotlin tries to solve the ["The Billion Dollar Mistake"] in another way by setting all values as non-nullable by default! You can explicitly mark values as optional by using the <code>?</code> operator which makes it <code>nullable</code>. The example code below shows that the value 'email' is optional.<pre><code><span class=a><span class=b>class</span><span class=c> User</span><span class=d>(</span><span class=b>val</span><span class=d> username: </span><span class=c>String</span><span class=d>, </span><span class=b>val</span><span class=d> password: </span><span class=c>String</span><span class=d>, </span><span class=b>val</span><span class=d> email: </span><span class=c>String</span><span class=d>?)</span></span>

<span class=a><span class=i>// Returns the user if found, else null</span></span>
<span class=a><span class=b>val</span><span class=d> user: </span><span class=c>User</span><span class=d>? </span><span class=e>=</span><span class=f> getUserByUsername</span><span class=d>(username)</span></span>
<span class=a><span class=b>val</span><span class=d> email: </span><span class=c>String</span><span class=d>? </span><span class=e>=</span><span class=d> user?.email</span></span>

<span class=a><span class=i>// Here we can create a new user and use the email from the previous user.</span></span>
<span class=a><span class=i>// If there isn't an user, we set a default email</span></span>
<span class=a><span class=b>val</span><span class=d> newUser </span><span class=e>=</span><span class=f> User</span><span class=d>(username, password, email ?: </span><span class=h>"default@email.xyz"</span><span class=d>)</span></span>
</code></pre><h2 id=read-basic-type-signatures>Read basic type signatures</h2><p>This is probably the easiest achievable skill to attain in Kotlin. Everything in Kotlin is strongly typed, which forces you to define the types. Below is an example containing a simple data-class in which the <code>Person</code> class has typed parameters. You can see that <code>name</code> is of type <code>String</code> and <code>age</code> is of type <code>Int</code>.<pre><code><span class=a><span class=b>class</span><span class=c> Person</span><span class=d>(</span><span class=b>val</span><span class=d> name: </span><span class=c>String</span><span class=d>, </span><span class=b>val</span><span class=d> age: </span><span class=c>Int</span><span class=d>)</span></span>
</code></pre><h2 id=constructing-destructuring>Constructing &amp; Destructuring</h2><p>Constructing is the process of putting values together and destructuring is a way to get the values back. A simple example is the <code>Pair</code> class in Kotlin.<pre><code><span class=a><span class=b>val</span><span class=d> name </span><span class=e>=</span><span class=h> "Kotlin"</span></span>
<span class=a><span class=b>val</span><span class=d> age </span><span class=e>=</span><span class=g> 9</span></span>
<span class=a><span class=b>val</span><span class=d> person </span><span class=e>=</span><span class=f> Pair</span><span class=d>(name, age)</span></span>
</code></pre><p>If you want to extract the values from the pair, you can destructure it on the left-hand side of the equation. The destructuring is done in the same order as the structuring. To make sure you only get certain specific values, you can use an underscore as a placeholder indicating that the value should be ignored.<pre><code><span class=a><span class=b>val</span><span class=d> (_, age) </span><span class=e>=</span><span class=f> Pair</span><span class=d>(</span><span class=h>"Kotlin"</span><span class=d>, </span><span class=g>9</span><span class=d>)</span></span>
<span class=a><span class=f>println</span><span class=d>(age)</span></span>
</code></pre><p>This also works for data classes in Kotlin.<h2 id=higher-order-functions-lambdas>Higher-Order Functions &amp; Lambdas</h2><p>This is nothing more than a fancy name for a function that either takes a function as an argument, or has a function as its return value, or both! Still confused? The most used and well-known example of a higher-order function is <code>map</code>. A <code>map</code> function is a function that takes a lambda (a function), calls it, and returns a list with the results of the map function, applied to each element of the original list. Here is an example of the usage of <code>map</code>:<pre><code><span class=a><span class=b>val</span><span class=d> squaredValues </span><span class=e>=</span><span class=f> listOf</span><span class=d>(</span><span class=g>1</span><span class=d>, </span><span class=g>2</span><span class=d>, </span><span class=g>3</span><span class=d>, </span><span class=g>4</span><span class=d>).</span><span class=f>map</span><span class=d> { it </span><span class=e>*</span><span class=d> it }</span></span>
</code></pre><h2 id=second-order-functions>Second-Order Functions</h2><p>These functions come right after the "Higher-Order Functions" and it takes a function that takes a function. Pretty abstract, right? You can find examples of this in mathematics where you create the formula for a parabola in code. A more widely used example is the concept of currying. Currying (sadly, it has nothing to do with the delicious dish) is the concept of breaking a function, which takes multiple arguments, into smaller functions which each take a single argument and return a new function. Currying is not supported out of the box, but it can be achieved by using helper functions.<pre><code><span class=a><span class=b>fun</span><span class=f> add</span><span class=d>(a: </span><span class=c>Int</span><span class=d>, b:</span><span class=c>Int</span><span class=d>): </span><span class=c>Int</span><span class=d> {</span></span>
<span class=a><span class=b>    return</span><span class=d> a </span><span class=e>+</span><span class=d> b</span></span>
<span class=a><span class=d>}</span></span>

<span class=a><span class=b>fun</span><span class=d> &#x3C;</span><span class=c>A</span><span class=d>, </span><span class=c>B</span><span class=d>, </span><span class=c>C</span><span class=d>> </span><span class=f>partial2</span><span class=d>(f: (</span><span class=c>A</span><span class=d>, </span><span class=c>B</span><span class=d>) -> </span><span class=c>C</span><span class=d>, a: </span><span class=c>A</span><span class=d>): (</span><span class=c>B</span><span class=d>) -> </span><span class=c>C</span><span class=d> {</span></span>
<span class=a><span class=b>    return</span><span class=d> { b: </span><span class=c>B</span><span class=d> -> </span><span class=c>f</span><span class=d>(</span><span class=c>a</span><span class=d>, </span><span class=c>b</span><span class=d>)}</span></span>
<span class=a><span class=d>}</span></span>

<span class=a><span class=i>// Break up add and set its first input to 1. This will return a new function</span></span>
<span class=a><span class=i>// that always adds 1 to the next argument.</span></span>
<span class=a><span class=b>val</span><span class=d> add1 </span><span class=e>=</span><span class=f> partial2</span><span class=d>(::</span><span class=f>add</span><span class=d>, </span><span class=g>1</span><span class=d>)</span></span>

<span class=a><span class=b>val</span><span class=d> result </span><span class=e>=</span><span class=f> add1</span><span class=d>(</span><span class=g>2</span><span class=d>) </span><span class=i>// result = 3</span></span>
</code></pre><p><code>Partial2</code> takes a function and the first argument of that function. This will return a new function that waits for the second argument to finish up the calculation. The new function can be passed around and applied to other values. Alternatively, you can do it with an extension method:<pre><code><span class=a><span class=b>fun</span><span class=d> &#x3C;</span><span class=c>A</span><span class=d>,</span><span class=c>B</span><span class=d>,</span><span class=c>C</span><span class=d>> </span><span class=f>Function2</span><span class=e>&#x3C;</span><span class=d>A,B,C</span><span class=e>></span><span class=d>.</span><span class=f>partial</span><span class=d>(a: </span><span class=c>A</span><span class=d>): (</span><span class=c>B</span><span class=d>) -> </span><span class=c>C</span><span class=d> {</span></span>
<span class=a><span class=b>    return</span><span class=d> {b </span><span class=b>-></span><span class=f> invoke</span><span class=d>(a, b)}</span></span>
<span class=a><span class=d>}</span></span>

<span class=a><span class=b>val</span><span class=d> add1: (</span><span class=c>Int</span><span class=d>) -> </span><span class=c>Int</span><span class=e> =</span><span class=d> (::</span><span class=f>add</span><span class=d>).</span><span class=f>partial</span><span class=d>(</span><span class=g>1</span><span class=d>)</span></span>
</code></pre><h2 id=functional-composition>Functional Composition</h2><p>Composition is, in abstraction, creating something new by putting things together. In the example below, we will combine two functions into new functions. The new function can be composed with another function which allows you to build up a more powerful function from smaller functions. This isn't something that comes out of the box in Kotlin, yet is still achievable! We can achieve it by using callable references and pass them to a compose helper function. This combines (composes) two functions together to get a new function.<pre><code><span class=a><span class=b>fun</span><span class=f> isOdd</span><span class=d>(x: </span><span class=c>Int</span><span class=d>) </span><span class=e>=</span><span class=d> x </span><span class=e>%</span><span class=g> 2</span><span class=e> !=</span><span class=g> 0</span></span>
<span class=a><span class=b>fun</span><span class=f> length</span><span class=d>(s: </span><span class=c>String</span><span class=d>) </span><span class=e>=</span><span class=d> s.length</span></span>

<span class=a><span class=i>// Define a function that takes two functions and return a new one.</span></span>
<span class=a><span class=b>fun</span><span class=d> &#x3C;</span><span class=c>A</span><span class=d>, </span><span class=c>B</span><span class=d>, </span><span class=c>C</span><span class=d>> </span><span class=f>compose</span><span class=d>(f: (</span><span class=c>B</span><span class=d>) -> </span><span class=c>C</span><span class=d>, g: (</span><span class=c>A</span><span class=d>) -> </span><span class=c>B</span><span class=d>): (</span><span class=c>A</span><span class=d>) -> </span><span class=c>C</span><span class=d> {</span></span>
<span class=a><span class=b>    return</span><span class=d> { x </span><span class=b>-></span><span class=f> f</span><span class=d>(</span><span class=f>g</span><span class=d>(x)) }</span></span>
<span class=a><span class=d>}</span></span>

<span class=a><span class=i>// Combine isOdd and length methods and store the combined function</span></span>
<span class=a><span class=i>// as variable.</span></span>
<span class=a><span class=b>val</span><span class=d> oddLength </span><span class=e>=</span><span class=f> compose</span><span class=d>(::</span><span class=f>isOdd</span><span class=d>, ::</span><span class=f>length</span><span class=d>)</span></span>

<span class=a><span class=b>val</span><span class=d> strings </span><span class=e>=</span><span class=f> listOf</span><span class=d>(</span><span class=h>"a"</span><span class=d>, </span><span class=h>"ab"</span><span class=d>, </span><span class=h>"abc"</span><span class=d>)</span></span>

<span class=a><span class=d>strings.</span><span class=f>filter</span><span class=d>(oddLength) </span><span class=e>==</span><span class=f> listOf</span><span class=d>(</span><span class=h>"a"</span><span class=d>, </span><span class=h>"abc"</span><span class=d>)</span></span>
</code></pre><h2 id=closing-words>Closing words</h2><p>Now you know all "beginner" concepts and skills to start writing functional code in Kotlin. All of this can be applied to existing code bases without much change. We looked at the basics and as you can read it is possible to code functionally in this language. We didn't go deep, but this is at least a promising start. If you're interested, The Standardized Ladder of Functional Programming discusses many other topics that can be applied to Kotlin with which you can dive deeper!</section><footer>Published on <time datetime=2020-08-03T00:00:00 itemprop=datePublished>2020-08-03</time><br>Tags: <a href=/tags/#functional-programming title="See all posts for Functional Programming">Functional Programming</a>, <a href=/tags/#kotlin title="See all posts for Kotlin">Kotlin</a><br>Source <a href=https:&#x2F;&#x2F;github.com&#x2F;brianvanburken&#x2F;brianvanburken.github.io&#x2F;tree&#x2F;master&#x2F;content/become-a-fire-keramik-with-kotlin.md target=_blank rel="noopener noreferrer" title="View post source on Github">on Github</a></footer></article><script data-goatcounter=https://brianvanburken.goatcounter.com/count async src=https://gc.zgo.at/count.js></script><noscript><img src="https://brianvanburken.goatcounter.com/count?p=/become-a-fire-keramik-with-kotlin/"></noscript>