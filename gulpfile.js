import fs from "fs";
import gulp from "gulp";
import htmlMinimizer from "gulp-html-minimizer";
import htmlnano from "htmlnano";
import postHtmlExternalLink from "posthtml-external-link";
import postHtmlInlineAssets from "posthtml-inline-assets";
import postHtmlMinifyClassnames from "posthtml-minify-classnames";
import postcss from "gulp-postcss";
import postcssCsso from "postcss-csso";
import postcssPurgecss from "@fullhuman/postcss-purgecss";
import posthtml from "gulp-posthtml";
import replace from "gulp-replace-string";
import through from "through2";
import uncss from "uncss";
import { getHighlighter } from "shiki";
import { transform } from "gulp-html-transform";

const source = process.env.BUILD_DIR || "_site";
const dirname = new URL(".", import.meta.url).pathname;
const theme = "ayu-dark";

function uncssStyles() {
  return through.obj(function (file, _encoding, cb) {
    if (file.isNull() || !file.isBuffer()) {
      return cb(null, file);
    }

    try {
      const content = String(file.contents);
      const styleSelector = /<style>(.*?)<\/style>/;
      const matches = styleSelector.exec(content);
      if (!matches) {
        return cb(null, file);
      }
      const css = matches[1];
      const html = content.replace(styleSelector, "");

      uncss(html, { raw: css }, (error, output) => {
        if (output) {
          file.contents = Buffer.from(
            content.replace(styleSelector, `<style>${output}</style>`),
          );
          cb(null, file);
        } else {
          cb(error, null);
        }
      });
    } catch (e) {
      return cb(e, file);
    }
  });
}

async function convertCode($) {
  const highlighter = await getHighlighter({
    themes: [theme],
    langs: [
      "css",
      "diff",
      "elixir",
      "elm",
      "html",
      "ini",
      "javascript",
      "json",
      "kotlin",
      "ruby",
      "typescript",
    ],
  });

  $("code").each(function () {
    const $code = $(this);
    const $parent = $code.parent();
    const isInlineCode = $parent[0].name !== "pre";
    const cls = $code.attr("class");
    const lang = cls ? cls.toString().replace("language-", "").trim() : "text";
    const content = $code.text();

    const highlighted = highlighter.codeToHtml(content, {
      lang,
      theme,
    });

    if (isInlineCode) {
      $code.attr("style", $(highlighted).attr("style"));
    } else {
      $parent.replaceWith(`<pre>${highlighted}</pre>`);
    }
  });

  // Now we replace all inline styles with classes to save space
  let css = "";
  let css_map = {};
  $("*[style]").each(function (index) {
    const style_content = $(this).attr("style").trim();
    const styles = style_content.split(";");

    for (let i = 0; i < styles.length; i++) {
      const style_key = styles[i].replace(/[\s;]/g, "").toUpperCase();

      const class_name = css_map.hasOwnProperty(style_key)
        ? css_map[style_key]
        : `shiki_${index}_${i}`;

      css += ` .${class_name} { ${styles[i]}; }\n`;
      css_map[style_key] = css_map[style_key] || class_name;

      $(this).addClass(class_name);
      $(this).removeAttr("style");
    }
  });
  const style_tag = $(`<style type="text/css">${css}</style>`);
  $("body").append(style_tag);

  // Remove empty span tags created by Shiki
  $("span:empty").remove();

  // Remove wrapper span tags created by Shiki
  $("span > span:first-child").each(function () {
    const content = $(this).parent().html();
    $(this).parent().replaceWith(content);
  });

  // Remove wrapper spans around whitespace
  $("span").each(function () {
    const content = $(this).text();
    if (content.trim() === "") {
      $(this).replaceWith(content);
    }
  });
  // Remove color class and wrapper that is the same as default set on code/pre tags
  const DEFAULT_COLOR_KEY = "COLOR:#BFBDB6";
  const default_color_class = css_map[DEFAULT_COLOR_KEY];
  default_color_class &&
    $(`.${default_color_class}`).each(function () {
      const content = $(this).html();
      $(this).replaceWith(content);
    });

  // Remove italic code generated by Shiki
  const ITALIC_KEY = "FONT-STYLE:ITALIC";
  const default_italic_class = css_map[ITALIC_KEY];
  default_italic_class &&
    $(`.${default_italic_class}`).each(function () {
      $(this).removeClass(default_italic_class);
    });

  // Remove background color on pre/code
  const BG_KEY = "BACKGROUND-COLOR:#0B0E14";
  const default_bg_class = css_map[BG_KEY];
  default_bg_class &&
    $(`.${default_bg_class}`).each(function () {
      $(this).removeClass(default_bg_class);
    });
}

gulp.task("html", function () {
  const plugins = [
    postHtmlExternalLink.posthtmlExternalLink(),
    postHtmlInlineAssets({
      cwd: dirname + "/" + source,
      root: dirname + "/" + source,
    }),
    postHtmlMinifyClassnames({
      genNameId: false,
    }),
    htmlnano({
      collapseWhitespace: "aggressive",
      removeComments: true,
      removeEmptyAttributes: true,
      removeAttributeQuotes: true,
      mergeStyles: true,
    }),
  ];

  const regex =
    /<span class="([a-z0-9_]+)">([^<]*)<\/span>(\s*)<span class="\1">/gm;

  return (
    gulp
      .src(source + "/**/*.html")
      .pipe(transform(convertCode))

      // Compress spans where next span has same class so lines with similair colors
      // fall under a single <span>
      // e.g. <span class="e">a</span> <span class="e">b</span>
      .pipe(replace(regex, '<span class="$1">$2$3'))
      // Do it again to ensure any extra are missed
      .pipe(replace(regex, '<span class="$1">$2$3'))

      .pipe(uncssStyles())
      .pipe(posthtml(plugins))
      .pipe(
        htmlMinimizer({
          removeOptionalTags: true,
        }),
      )
      .pipe(uncssStyles())
      .pipe(gulp.dest(source))
  );
});

gulp.task("css", function () {
  const csso = postcssCsso({
    forceMediaMerge: true,
    comments: false,
  });
  const plugins = [
    csso,
    postcssPurgecss({
      content: [source + "/**/*.html"],
    }),
    csso,
  ];

  return gulp
    .src(source + "/**/*.css")
    .pipe(postcss(plugins))
    .pipe(gulp.dest(source));
});

gulp.task("default", gulp.series(["css", "html"]));
