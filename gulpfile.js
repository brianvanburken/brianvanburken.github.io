const gulp = require("gulp");
const posthtml = require("gulp-posthtml");
const postcss = require("gulp-postcss");
const htmlMinimizer = require("gulp-html-minimizer");
const { transform } = require("gulp-html-transform");
const uncss = require("uncss");
const through = require("through2");
const shiki = require("shiki");
const replace = require("gulp-replace-string");

const source = process.env.BUILD_DIR || "_site";

function uncssStyles() {
  return through.obj(function (file, _encoding, cb) {
    if (file.isNull() || !file.isBuffer()) {
      return cb(null, file);
    }

    try {
      const content = String(file.contents);
      const styleSelector = /<style>(.*?)<\/style>/;
      const matches = styleSelector.exec(content);
      if (!matches) {
        return cb(null, file);
      }
      const css = matches[1];
      const html = content.replace(styleSelector, "");

      uncss(html, { raw: css }, (error, output) => {
        if (output) {
          file.contents = Buffer.from(
            content.replace(styleSelector, `<style>${output}</style>`)
          );
          cb(null, file);
        } else {
          cb(error, null);
        }
      });
    } catch (e) {
      return cb(e, file);
    }
  });
}

async function convertCode($) {
  const theme = await shiki.loadTheme("../../shiki-themes/ayu-dark.json");
  const highlighter = await shiki.getHighlighter({ theme });

  $("code").each(function () {
    const $code = $(this);
    const $parent = $code.parent();
    const isInlineCode = $parent[0].name !== "pre";
    const cls = $code.attr("class");
    const lang = cls ? cls.toString().replace("language-", "").trim() : "text";
    const content = $code.text();

    const highlighted = highlighter.codeToHtml(content, { lang });

    if (isInlineCode) {
      $code.attr("style", $(highlighted).attr("style"));
    } else {
      $parent.replaceWith(highlighted);
    }
  });

  // Now we replace all inline styles with classes to save space
  let css = "";
  let css_map = {};
  $("*[style]").each(function (index) {
    const style_content = $(this).attr("style").trim();
    const styles = style_content.split(";");

    for (let i = 0; i < styles.length; i++) {
      const style_key = styles[i].replace(/[\s;]/g, "").toUpperCase();

      const class_name = css_map.hasOwnProperty(style_key)
        ? css_map[style_key]
        : `shiki_${index}_${i}`;

      css += ` .${class_name} { ${styles[i]}; }\n`;
      css_map[style_key] = css_map[style_key] || class_name;

      $(this).addClass(class_name);
      $(this).removeAttr("style");
    }
  });
  const style_tag = $(`<style type="text/css">${css}</style>`);
  $("body").append(style_tag);

  // Remove empty span tags created by Shiki
  $("span:empty").remove();

  // Remove wrapper span tags created by Shiki
  $("span > span:first-child").each(function () {
    const content = $(this).parent().html();
    $(this).parent().replaceWith(content);
  });

  // Remove wrapper spans around whitespace
  $("span").each(function () {
    const content = $(this).text();
    if (content.trim() === "") {
      $(this).replaceWith(content);
    }
  });
  // Remove color class and wrapper that is the same as default set on code/pre tags
  const DEFAULT_COLOR_KEY = "COLOR:#BFBDB6";
  const default_color_class = css_map[DEFAULT_COLOR_KEY];
  default_color_class &&
    $(`.${default_color_class}`).each(function () {
      const content = $(this).html();
      $(this).replaceWith(content);
    });

  // Remove italic code generated by Shiki
  const ITALIC_KEY = "FONT-STYLE:ITALIC";
  const default_italic_class = css_map[ITALIC_KEY];
  default_italic_class &&
    $(`.${default_italic_class}`).each(function () {
      $(this).removeClass(default_italic_class);
    });

  // Remove background color on pre/code
  const BG_KEY = "BACKGROUND-COLOR:#0B0E14";
  const default_bg_class = css_map[BG_KEY];
  default_bg_class &&
    $(`.${default_bg_class}`).each(function () {
      $(this).removeClass(default_bg_class);
    });
}

gulp.task("html", function () {
  const plugins = [
    require("posthtml-external-link").posthtmlExternalLink(),
    require("posthtml-inline-assets")({
      cwd: __dirname + "/" + source,
      root: __dirname + "/" + source,
    }),
    require("posthtml-minify-classnames")(),
    require("htmlnano")({
      collapseWhitespace: "aggressive",
      removeComments: true,
      removeEmptyAttributes: true,
      removeAttributeQuotes: true,
    }),
  ];

  const regex =
    /<span class="([a-z0-9_]+)">([^<]*)<\/span>(\s*)<span class="\1">/gm;

  return (
    gulp
      .src(source + "/**/*.html")
      .pipe(transform(convertCode))

      // Compress spans where next span has same class so lines with similair colors
      // fall under a single <span>
      // e.g. <span class="e">a</span> <span class="e">b</span>
      .pipe(replace(regex, '<span class="$1">$2$3'))
      // Do it again to ensure any extra are missed
      .pipe(replace(regex, '<span class="$1">$2$3'))

      .pipe(uncssStyles())
      .pipe(posthtml(plugins))
      .pipe(
        htmlMinimizer({
          removeOptionalTags: true,
        })
      )
      .pipe(uncssStyles())
      .pipe(gulp.dest(source))
  );
});

gulp.task("css", function () {
  const csso = require("postcss-csso")({
    forceMediaMerge: true,
    comments: false,
  });
  const plugins = [
    csso,
    require("@fullhuman/postcss-purgecss")({
      content: [source + "/**/*.html"],
    }),
    csso,
  ];

  return gulp
    .src(source + "/**/*.css")
    .pipe(postcss(plugins))
    .pipe(gulp.dest(source));
});

gulp.task("default", gulp.series(["css", "html"]));
