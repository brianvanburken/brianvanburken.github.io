<!DOCTYPE html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/atom+xml title="RSS Feed" href=https://brianvanburken.nl/feed.xml><title>Solving Challenge with Elixir&#x27;s Compile-Time Functions | Brian van Burken</title><meta property=og:title content="Solving Challenge with Elixir&#x27;s Compile-Time Functions"><meta name=description content="I love solving small programming challenges. One of the many challenges on this website is about transcribing DNA nucleotides to RNA nucleotides. I was able to solve this by using Elixir."><meta property=og:description content="I love solving small programming challenges. One of the many challenges on this website is about transcribing DNA nucleotides to RNA nucleotides. I was able to solve this by using Elixir."><meta property=og:type content=article><meta property=og:url content=https:&#x2F;&#x2F;brianvanburken.nl&#x2F;solving-challenges-with-elixirs-compile-time-function&#x2F;><meta property=og:site_name content="Brian van Burken"><link rel=canonical href=https:&#x2F;&#x2F;brianvanburken.nl&#x2F;solving-challenges-with-elixirs-compile-time-function&#x2F;><meta property=article:published_time content=2019-05-01T00:00:00+00:00><style>html{color:#fff;background:#0b0e14}@media (prefers-color-scheme:light){html{color:#0b0e14;background:#fff}}body{font-family:"Avenir Next","Open Sans",Helvetica,sans-serif;font-size:1.125rem;max-width:70ch;margin:1.5rem auto;padding:0 1.5rem}article,code,footer,h1,h2,p,pre{margin:1.5rem 0;line-height:1.5rem}h1{font-size:2.5rem;line-height:3rem}p{text-align:justify}img{max-width:100%}h2{margin-top:3rem}a,a code{color:#fa3}a:visited{color:#ff9500}a:focus,a:hover{color:#ffbf66}footer{border-top:1px solid #bfbdb6;padding-top:1.5rem}code,pre{font-size:.875rem;word-spacing:normal;word-break:normal;word-wrap:normal;hyphens:none;color:#bfbdb6;background:#0b0e14;border-radius:.375rem}pre{overflow:auto;padding:1.5rem}p code{line-height:1;outline:3px solid #0b0e14;margin:0 2px}.b{color:#ff8f40}.c{color:#59c2ff}.e{color:#bfbdb6}.i{color:#f29668}.g{color:#bfbdb6b3}.f{color:#aad94c}.k{color:#5a6673}.d{color:#ffb454}.j{color:#d2a6ff}.h{color:#95e6cb}</style><p><a href=/ title="Overview of all my writings">Writings</a> | <a href=https://github.com/brianvanburken title="Visit my GitHub profile" target=_blank rel="noopener noreferrer">GitHub</a> | <a href=https://linkedin.com/in/brianvanburken title="Visit my LinkedIn profile" target=_blank rel="noopener noreferrer">LinkedIn</a><article itemscope itemtype=http://schema.org/BlogPosting><h1 itemprop="name headline">Solving Challenge with Elixir&#x27;s Compile-Time Functions</h1><section itemprop=articleBody><p>I love solving small programming challenges. If you do too, I recommend <a rel="noopener nofollow noreferrer external" target=_blank href=https://exercism.io/ >exercism.io</a>. One of the many challenges on this website is about transcribing DNA nucleotides to RNA nucleotides. I was able to solve this by using Elixir. I also found that I could apply metaprogramming to improve my answer. In this blog post, I will walk you through this process of improvement.<h2 id=basics>Basics</h2><p>Before we can solve this challenge, we need to figure out the mapping between the nucleotides that make up a DNA strand and the corresponding representation in RNA. The mapping is A to U, G to C, T to A, and C to G. I've drawn out an example below:<p><img src=/assets/solving-challenges-with-elixirs-compile-time-function/rna_transcription.jpg alt="Drawing of DNA string conversion to RNA"><p>Now let's implement this in Elixir! We can define multiple functions with the same name which are referred to as same head functions. In addition, we can use pattern matching on the argument to represent the mapping between the nucleotides. Doing so, we end up with the code below:<pre><code><span class=a><span class=b>defmodule</span><span class=c> RNATranscription</span><span class=b> do</span></span>
<span class=a><span class=b>  def</span><span class=d> to_rna</span><span class=e>(</span><span class=f>"G"</span><span class=e>)</span><span class=g>,</span><span class=h> do:</span><span class=f> "C"</span></span>
<span class=a><span class=b>  def</span><span class=d> to_rna</span><span class=e>(</span><span class=f>"C"</span><span class=e>)</span><span class=g>,</span><span class=h> do:</span><span class=f> "G"</span></span>
<span class=a><span class=b>  def</span><span class=d> to_rna</span><span class=e>(</span><span class=f>"T"</span><span class=e>)</span><span class=g>,</span><span class=h> do:</span><span class=f> "A"</span></span>
<span class=a><span class=b>  def</span><span class=d> to_rna</span><span class=e>(</span><span class=f>"A"</span><span class=e>)</span><span class=g>,</span><span class=h> do:</span><span class=f> "U"</span></span>
<span class=a><span class=b>end</span></span>
</code></pre><p>Following this, we can try out our module in the Elixir REPL called IEx and give it a valid DNA nucleotide. As can be seen below, this returns the correct corresponding RNA nucleotide:<pre><code><span class=a><span class=e>iex</span><span class=i>></span><span class=d> import_file</span><span class=e>(</span><span class=f>"rna.ex"</span><span class=e>)</span></span>
<span class=a><span class=e>iex</span><span class=i>></span><span class=c> RNATranscription</span><span class=g>.</span><span class=d>to_rna</span><span class=e>(</span><span class=f>"T"</span><span class=e>)</span></span>
<span class=a><span class=f>"A"</span></span>
</code></pre><p>Now we can use this module to take a DNA strand and split it into a list of DNA nucleotides. Each of these nucleotides is then mapped to its RNA equivalent and joined to produce the RNA strand. One way to do this is by using the REPL:<pre><code><span class=a><span class=e>iex</span><span class=i>></span><span class=e> strand </span><span class=i>=</span><span class=f> "GCAATTA"</span></span>
<span class=a><span class=e>iex</span><span class=i>></span><span class=e> strand </span><span class=i>|></span><span class=c> String</span><span class=g>.</span><span class=d>graphemes</span><span class=e>() </span><span class=i>|></span><span class=c> Enum</span><span class=g>.</span><span class=d>map</span><span class=e>(&#x26;</span><span class=c>RNATranscription</span><span class=g>.</span><span class=d>to_rna</span><span class=i>/</span><span class=j>1</span><span class=e>) </span><span class=i>|></span><span class=c> Enum</span><span class=g>.</span><span class=d>join</span><span class=e>()</span></span>
<span class=a><span class=f>"CGUUAAU"</span></span>
</code></pre><p>This bit of code could be placed in a method called "decode" and we would be done! But now imagine the discovery of new RNA or DNA nucleotides. This would mean that additional letters would have to be added to our code. We could write a few new functions matching these new DNA nucleotides that will return the RNA ones. Though doable by hand, we could leverage the power of Elixir metaprogramming and define functions from a mapping so future extensions are easy. Let's have some fun!<h2 id=metaprogramming>Metaprogramming</h2><p>Before we get into applying metaprogramming to our example, I want to go a bit more in-depth on the subject. One amazing thing about Elixir is that it is mostly written in.. Elixir! According to Github, at the time of writing this blog post, it contains about 90% Elixir code and only 9% Erlang code. Having a language written in the same language as the source code makes it easier to read and contribute to because you already know the language. Most of it is built using metaprogramming on top of a small core. An example of this is <code>if/else</code>. This is a simple macro for <code>case</code>. So the example code below...<pre><code><span class=a><span class=b>if</span><span class=d> is_thruthy?</span><span class=e>() </span><span class=b>do</span></span>
<span class=a><span class=d>  do_something</span><span class=e>()</span></span>
<span class=a><span class=b>else</span></span>
<span class=a><span class=d>  do_something_else</span><span class=e>()</span></span>
<span class=a><span class=b>end</span></span>
</code></pre><p>..gets compiled down in an intermitted step:<pre><code><span class=a><span class=b>case</span><span class=d> is_thruthy?</span><span class=e>() </span><span class=b>do</span></span>
<span class=a><span class=e>  x </span><span class=b>when</span><span class=e> x </span><span class=i>in</span><span class=e> [</span><span class=j>false</span><span class=g>,</span><span class=j> nil</span><span class=e>] </span><span class=i>-></span></span>
<span class=a><span class=d>    do_something_else</span><span class=e>()</span></span>
<span class=a><span class=k>  _</span><span class=i> -></span></span>
<span class=a><span class=d>    do_something</span><span class=e>()</span></span>
<span class=a><span class=b>end</span></span>
</code></pre><p>You can read more about the source code in the <a rel="noopener nofollow noreferrer external" target=_blank href=https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel.ex#L3093><code>Kernel</code></a> library. This will show you how Elixir works beautifully. You can see the only falsely values are <code>false</code> and <code>nil</code>, everything else is truthy.<p>To get a sense of how we can implement something like this, let's try something out in the REPL. Using <a rel="noopener nofollow noreferrer external" target=_blank href=https://hexdocs.pm/elixir/Kernel.SpecialForms.html#unquote/1><code>unquote</code></a> we can take an expression and make it static on compile time. And with <a rel="noopener nofollow noreferrer external" target=_blank href=https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2><code>quote</code></a> we can receive the AST from the block passed to check what we've created. The AST is what Elixir uses to represent our code before compiling down to Erlang. To see what the AST represents we use <a rel="noopener nofollow noreferrer external" target=_blank href=https://hexdocs.pm/elixir/Macro.html#to_string/2><code>Macro.to_string/1</code></a>.<pre><code><span class=a><span class=e>iex</span><span class=i>></span><span class=e> dna </span><span class=i>=</span><span class=f> "G"</span></span>
<span class=a><span class=e>iex</span><span class=i>></span><span class=e> ast </span><span class=i>=</span><span class=b> quote do</span></span>
<span class=a><span class=i>..</span><span class=g>.</span><span class=i>></span><span class=d> unquote</span><span class=e>(dna)</span></span>
<span class=a><span class=i>..</span><span class=g>.</span><span class=i>></span><span class=b> end</span></span>
<span class=a><span class=e>iex</span><span class=i>></span><span class=e> dna </span><span class=i>=</span><span class=f> "C"</span></span>
<span class=a><span class=e>iex</span><span class=i>></span><span class=c> IO</span><span class=g>.</span><span class=d>puts</span><span class=c> Macro</span><span class=g>.</span><span class=d>to_string</span><span class=e>(ast)</span></span>
<span class=a><span class=f>"G"</span></span>
</code></pre><p>As you can see in the code above, the unquote function returns the value <code>"G"</code> even if the value of <code>dna</code> is changed afterward. Through additional experimenting, we can find out if this can be used to set the value to match the argument in our same head pattern matching. We do this by writing the <code>to_rna</code> as we normally would but swapping out the argument and return value with the unquoted values of the DNA and RNA.<pre><code><span class=a><span class=e>iex</span><span class=i>></span><span class=e> dna </span><span class=i>=</span><span class=f> "G"</span></span>
<span class=a><span class=e>iex</span><span class=i>></span><span class=e> rna </span><span class=i>=</span><span class=f> "C"</span></span>
<span class=a><span class=e>iex</span><span class=i>></span><span class=e> ast </span><span class=i>=</span><span class=b> quote do</span></span>
<span class=a><span class=i>..</span><span class=g>.</span><span class=i>></span><span class=b> def</span><span class=d> to_rna</span><span class=e>(</span><span class=d>unquote</span><span class=e>(dna))</span><span class=g>,</span><span class=h> do:</span><span class=d> unquote</span><span class=e>(rna)</span></span>
<span class=a><span class=i>..</span><span class=g>.</span><span class=i>></span><span class=b> end</span></span>
<span class=a><span class=e>iex</span><span class=i>></span><span class=c> IO</span><span class=g>.</span><span class=d>puts</span><span class=c> Macro</span><span class=g>.</span><span class=d>to_string</span><span class=e>(ast)</span></span>
<span class=a><span class=d>def</span><span class=e>(</span><span class=d>to_rna</span><span class=e>(</span><span class=f>"G"</span><span class=e>)) </span><span class=b>do</span></span>
<span class=a><span class=f>  "C"</span></span>
<span class=a><span class=b>end</span></span>
</code></pre><p>As you can see, the value <code>"G"</code> is set as the argument and <code>"C"</code> is set as the return value. This looks exactly like one of the functions we wrote by hand. But instead of writing it manually, we've used the value of <code>dna</code> to set the value on which the <code>to_rna</code> function needs to match and <code>rna</code> to set as the return value. Knowing this, we can bring everything together and create functions for our mapping. We can create the DNA to RNA mapping by creating a function for each key and value pair that matches on the DNA and returns the RNA. We'll use a simple <code>for</code>-comprehension for looping through our mapping:<pre><code><span class=a><span class=b>defmodule</span><span class=c> RNATranscription</span><span class=b> do</span></span>
<span class=a><span class=e>  mapping </span><span class=i>=</span><span class=e> %{ </span><span class=f>"G"</span><span class=i> =></span><span class=f> "C"</span><span class=g>,</span><span class=f> "C"</span><span class=i> =></span><span class=f> "G"</span><span class=g>,</span><span class=f> "T"</span><span class=i> =></span><span class=f> "A"</span><span class=g>,</span><span class=f> "A"</span><span class=i> =></span><span class=f> "U"</span><span class=e> }</span></span>
<span class=a><span class=b>  for</span><span class=e> { dna</span><span class=g>,</span><span class=e> rna } </span><span class=i>&#x3C;-</span><span class=e> mapping </span><span class=b>do</span></span>
<span class=a><span class=b>    def</span><span class=d> to_rna</span><span class=e>(</span><span class=d>unquote</span><span class=e>(dna))</span><span class=g>,</span><span class=h> do:</span><span class=d> unquote</span><span class=e>(rna)</span></span>
<span class=a><span class=b>  end</span></span>
<span class=a><span class=b>end</span></span>
</code></pre><p>After loading the file in the REPL, it gets compiled and all functions get defined:<pre><code><span class=a><span class=e>iex</span><span class=i>></span><span class=d> import_file</span><span class=e>(</span><span class=f>"rna.ex"</span><span class=e>)</span></span>
<span class=a><span class=e>iex</span><span class=i>></span><span class=c> RNATranscription</span><span class=g>.</span><span class=d>to_rna</span><span class=e>(</span><span class=f>"T"</span><span class=e>)</span></span>
<span class=a><span class=f>"A"</span></span>
</code></pre><p>And there you go, we've created compile-time functions! We could take the automation even further by hosting the mapping somewhere, using a hook to create an Elixir package when it changes, and publish it without the interference of a developer.<h2 id=in-conclusion>In conclusion</h2><p>Elixir macros allow us to create awesome stuff. Though this awesomeness does come with a word of caution. It might be harder to understand what your code does and where some functions come from. New developers to your project with macros might have a hard time finding their way around. It is a tradeoff you have to make. Some might argue that using macros for a small mapping such as in our example above might be overkill. And I won't argue with that. However, it is fun to write and show you how you can define compile-time functions.<p>If you are interested in learning more about macros in Elixir I highly recommend the book Metaprogramming Elixir which goes deeper into the subject.<p>*[DNA]: DeoxyriboNucleic Acid *[RNA]: RiboNucleic Acid *[REPL]: Read-Evaluate-Print Loop *[IEx]: Interactive Elixir *[AST]: Abstract Syntax Tree</section><footer>Published on <time datetime=2019-05-01T00:00:00 itemprop=datePublished>2019-05-01</time><br>Tags: <a href=/tags/#ast title="See all posts for AST">AST</a>, <a href=/tags/#compile-time title="See all posts for Compile Time">Compile Time</a>, <a href=/tags/#elixir title="See all posts for Elixir">Elixir</a>, <a href=/tags/#macro title="See all posts for Macro">Macro</a><br>Source <a href=https:&#x2F;&#x2F;github.com&#x2F;brianvanburken&#x2F;brianvanburken.github.io&#x2F;tree&#x2F;master&#x2F;content/solving-challenges-with-elixirs-compile-time-function.md target=_blank rel="noopener noreferrer" title="View post source on Github">on Github</a></footer></article><script data-goatcounter=https://brianvanburken.goatcounter.com/count async src=https://gc.zgo.at/count.js></script><noscript><img src="https://brianvanburken.goatcounter.com/count?p=/solving-challenges-with-elixirs-compile-time-function/"></noscript>