<!DOCTYPE html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/atom+xml title="RSS Feed" href=https://brianvanburken.nl/feed.xml><title>Pre-render Syntax Highlighting with Prism in Jekyll | Brian van Burken</title><meta property=og:title content="Pre-render Syntax Highlighting with Prism in Jekyll"><meta name=description content="To get a considerable performance boost for this blog, I decided to pre-render all the code when building. So no need for a large JavaScript file."><meta property=og:description content="To get a considerable performance boost for this blog, I decided to pre-render all the code when building. So no need for a large JavaScript file."><meta property=og:type content=article><meta property=og:url content=https:&#x2F;&#x2F;brianvanburken.nl&#x2F;pre-render-syntax-highlighting-with-prism-in-jekyll&#x2F;><meta property=og:site_name content="Brian van Burken"><link rel=canonical href=https:&#x2F;&#x2F;brianvanburken.nl&#x2F;pre-render-syntax-highlighting-with-prism-in-jekyll&#x2F;><meta property=article:published_time content=2021-12-01T00:00:00+00:00><style>html{color:#fff;background:#0b0e14}@media (prefers-color-scheme:light){html{color:#0b0e14;background:#fff}}body{font-family:"Avenir Next","Open Sans",Helvetica,sans-serif;font-size:1.125rem;max-width:70ch;margin:1.5rem auto;padding:0 1.5rem}article,code,footer,h1,p,pre{margin:1.5rem 0;line-height:1.5rem}h1{font-size:2.5rem;line-height:3rem}sup{line-height:1;font-size:.75rem}p{text-align:justify}img{max-width:100%}a,a code{color:#fa3}a:visited{color:#ff9500}a:focus,a:hover{color:#ffbf66}footer{border-top:1px solid #bfbdb6;padding-top:1.5rem}code,pre{font-size:.875rem;word-spacing:normal;word-break:normal;word-wrap:normal;hyphens:none;color:#bfbdb6;background:#0b0e14;border-radius:.375rem}pre{overflow:auto;padding:1.5rem}p code{line-height:1;outline:3px solid #0b0e14;margin:0 2px}.k{color:#ff8f40}.b{color:#bfbdb6}.c{color:#f29668}.h{color:#39bae6}.f{color:#bfbdb6b3}.e{color:#aad94c}.d{color:#ffb454}.j{color:#d2a6ff}.l{color:#95e6cb}.g{color:#39bae680}.m{color:#f07178}</style><p><a href=/ title="Overview of all my writings">Writings</a> | <a href=https://github.com/brianvanburken title="Visit my GitHub profile" target=_blank rel="noopener noreferrer">GitHub</a> | <a href=https://linkedin.com/in/brianvanburken title="Visit my LinkedIn profile" target=_blank rel="noopener noreferrer">LinkedIn</a><article itemscope itemtype=http://schema.org/BlogPosting><h1 itemprop="name headline">Pre-render Syntax Highlighting with Prism in Jekyll</h1><section itemprop=articleBody><p>One of the most significant slowdowns of this blog was using <a rel="noopener nofollow noreferrer external" target=_blank href=https://prismjs.com/ >Prism</a> for syntax highlighting of code blocks. While Prism isn't that big, adding more and more languages can make it grow large. If you wanted to write blog posts about all languages that Prism could support, you would end up with a 400kb+ monstrosity. I already have various blogposts for different languages, and I want to write about any language I like. So I wondered how to achieve this without slowing down my blog for my visitors.<p>Since the output of Prism is HTML, I started looking into capturing this. My first attempt was to build a crawler that would go to each blogpost, execute JavaScript, and take the final rendered version to deploy. While this initially worked, it had a few challenges. One is the slowness of having to startup and render each page using a headless browser. Also, each rendered page still included the unwanted <code>script</code> tag to Prism.<p>After doing some more research, I decided to take a whole different approach. This time I would write my own Jekyll plugin. It extracts code blocks, passes them to the Prism highlight function, and returns the HTML output. The Prism highlight function takes three parameters: code, Prism language, code language. Executing the function would look like this.<pre><code><span class=a><span class=b>Prism</span><span class=c>.</span><span class=d>highlight</span><span class=b>(</span></span>
<span class=a><span class=e>  'var a = "Hello world!";'</span><span class=f>,</span></span>
<span class=a><span class=b>  Prism</span><span class=c>.</span><span class=b>languages</span><span class=c>.</span><span class=b>javascript</span><span class=f>,</span></span>
<span class=a><span class=e>  "javascript"</span></span>
<span class=a><span class=b>)</span><span class=f>;</span></span>
</code></pre><p>And this would give us HTML with the syntax highlight tags added.<pre><code><span class=a><span class=g>&#x3C;</span><span class=h>span</span><span class=d> class</span><span class=f>=</span><span class=e>"token keyword"</span><span class=g>></span><span class=b>var</span><span class=g>&#x3C;/</span><span class=h>span</span><span class=g>></span><span class=b> a </span><span class=g>&#x3C;</span><span class=h>span</span><span class=d> class</span><span class=f>=</span><span class=e>"token operator"</span><span class=g>></span><span class=b>=</span><span class=g>&#x3C;/</span><span class=h>span</span><span class=g>></span></span>
<span class=a><span class=g>&#x3C;</span><span class=h>span</span><span class=d> class</span><span class=f>=</span><span class=e>"token string"</span><span class=g>></span><span class=b>"Hello world!"</span><span class=g>&#x3C;/</span><span class=h>span</span></span>
<span class=a><span class=g>>&#x3C;</span><span class=h>span</span><span class=d> class</span><span class=f>=</span><span class=e>"token punctuation"</span><span class=g>></span><span class=b>;</span><span class=g>&#x3C;/</span><span class=h>span</span><span class=g>></span></span>
</code></pre><p>There are a few ways to achieve this. One would be to write a custom liquid-tag<sup class=i><a href=#1>1</a></sup> which would replace the code block in markdown. Another would be to listen for the pre-render event using Jekyll <a rel="noopener nofollow noreferrer external" target=_blank href=https://jekyllrb.com/docs/plugins/hooks/ >Hooks</a> and then extract the code. I first went with the Liquid tag option and was successful. While it worked, all the markdown editors could not understand the custom tags and render a preview. So I finally decided to go with the hook option.<p><a rel="noopener nofollow noreferrer external" target=_blank href=https://pages.github.com/ >Github Pages</a>, where I host my blog, doesn't support custom plugins. So I switched from the <code>github-pages</code> gem to the <code>jekyll</code> gem and created my build process.<p>To create a custom plugin, I needed to create a directory in the project root called <code>_plugins</code> and place a Ruby file in it. Jekyll would then load this directory and its contents. I created a new file called <code>prism.rb</code> and placed it in <code>_plugins</code>.<p>Next, I added the <a rel="noopener nofollow noreferrer external" target=_blank href=https://github.com/rails/execjs>ExecJS</a> gem to the <code>Gemfile</code> and ran <code>bundle install</code>. ExecJS lets you run JavaScript code from Ruby. I use this to execute the Prism highlight function and capture its output.<p>In the <code>prism.rb</code> file, we can start adding hooks for events. The first hook would be to listen to the <code>pre_render</code> event on <code>posts</code>. The hook then gives us a <code>Jekyll::Document</code> from which we can ask the content of the blog post. It would look like this.<pre><code><span class=a><span class=h>Jekyll</span><span class=f>::</span><span class=h>Hooks</span><span class=f>.</span><span class=d>register</span><span class=b>(</span><span class=j>:posts</span><span class=f>,</span><span class=j> :pre_render</span><span class=b>) </span><span class=k>do</span><span class=f> |</span><span class=b>document</span><span class=f>|</span></span>
<span class=a><span class=b>    content </span><span class=c>=</span><span class=b> document</span><span class=f>.</span><span class=d>content</span></span>
<span class=a><span class=k>end</span></span>
</code></pre><p>Now that we have the blogpost content, we need to find all the code blocks present in the code. A code block starts with three backticks, followed by the language, on the following line the code, and ends with three backticks. I used Regex to get the whole code block, language, and only the code. Using <code>String.scan</code>, we can get all the matches.<pre><code><span class=a><span class=h>Jekyll</span><span class=f>::</span><span class=h>Hooks</span><span class=f>.</span><span class=d>register</span><span class=b>(</span><span class=j>:posts</span><span class=f>,</span><span class=j> :pre_render</span><span class=b>) </span><span class=k>do</span><span class=f> |</span><span class=b>document</span><span class=f>|</span></span>
<span class=a><span class=b>    content </span><span class=c>=</span><span class=b> document</span><span class=f>.</span><span class=d>content</span></span>
<span class=a><span class=b>    content</span><span class=f>.</span><span class=d>scan</span><span class=b> /</span><span class=l>((`{3})(?:\s*)(\w+)((?:.|\n)*?)\2)</span><span class=b>/</span><span class=k> do</span><span class=f> |</span><span class=b>match</span><span class=f>|</span></span>
<span class=a><span class=b>        code_block </span><span class=c>=</span><span class=b> match[</span><span class=j>0</span><span class=b>]</span></span>
<span class=a><span class=b>        language </span><span class=c>=</span><span class=b> match[</span><span class=j>2</span><span class=b>]</span></span>
<span class=a><span class=b>        code </span><span class=c>=</span><span class=b> match[</span><span class=j>3</span><span class=b>]</span></span>
<span class=a><span class=k>    end</span></span>
<span class=a><span class=k>end</span></span>
</code></pre><p>Now we have everything to call the highlight function. To call the function, we need to start the JavaScript runtime and load Prism. First, we need to download Prism JavaScript code. You can do that <a rel="noopener nofollow noreferrer external" target=_blank href=https://prismjs.com/download.html>here</a>; while you're at it, download the CSS file you'll need later. I checked all the languages which you don't have to. Note that checking all languages makes the file larger, thus making it longer to load and slowing down your build. My final <code>prism.min.js</code> file is a hefty 463kb on the disk; luckily, we don't need to include this on the website! We can place the file in the <code>_plugins</code> directory next to our plugin <code>prism.rb</code>.<p>We then load the contents of our <code>prism.min.js</code> and pass it to <code>ExecJS.compile</code>. To do this, you add <code>require "execjs"</code> to the top of <code>prism.rb</code> and use <code>File.read</code> to load the JavaScript file. We place the loading and compiling of the JavaScript before the code block matching, so we don't have to load it each time we come across a code block.<pre><code><span class=a><span class=f>...</span></span>
<span class=a><span class=b>file </span><span class=c>=</span><span class=b> __dir__ </span><span class=c>+</span><span class=e> "/prism.min.js"</span></span>
<span class=a><span class=b>source </span><span class=c>=</span><span class=h> File</span><span class=f>.</span><span class=d>read</span><span class=b>(file)</span></span>
<span class=a><span class=b>js </span><span class=c>=</span><span class=h> ExecJS</span><span class=f>.</span><span class=d>compile</span><span class=b>(source)</span></span>
<span class=a><span class=b>content</span><span class=f>.</span><span class=d>scan</span><span class=b> /</span><span class=l>((`{3})(?:\s*)(\w+)((?:.|\n)*?)\2)</span><span class=b>/</span><span class=k> do</span><span class=f> |</span><span class=b>match</span><span class=f>|</span></span>
<span class=a><span class=f>...</span></span>
</code></pre><p>Next, we call the highlight function, using the compiled JavaScript for each of the code blocks. We then wrap the output with <code>pre</code> and <code>code</code> HTML tags and replace the code block in the blogpost with our pre-rendered HTML. Calling the function looks like this.<pre><code><span class=a><span class=b>js_code </span><span class=c>=</span><span class=e> %Q[Prism.highlight(`</span><span class=k>#{</span><span class=b>code</span><span class=k>}</span><span class=e>`, Prism.languages.</span><span class=k>#{</span><span class=b>language</span><span class=k>}</span><span class=e>, '</span><span class=k>#{</span><span class=b>language</span><span class=k>}</span><span class=e>')]</span></span>
<span class=a><span class=b>output </span><span class=c>=</span><span class=b> js</span><span class=f>.</span><span class=m>eval</span><span class=b>(js_code)</span></span>
<span class=a><span class=b>output </span><span class=c>=</span><span class=e> &#x3C;&#x3C;~EOS</span></span>
<span class=a><span class=e>&#x3C;pre class="n o"s0">#{</span><span class=b>language</span><span class=k>}</span><span class=e>">&#x3C;code class='language-</span><span class=k>#{</span><span class=b>language</span><span class=k>}</span><span class=e>'></span><span class=k>#{</span><span class=b>output</span><span class=k>}</span><span class=e>&#x3C;/code>&#x3C;/pre></span></span>
<span class=a><span class=e>EOS</span></span>
</code></pre><p>Putting it all together, we get a working version.<pre><code><span class=a><span class=k>require</span><span class=e> "execjs"</span></span>

<span class=a><span class=h>Jekyll</span><span class=f>::</span><span class=h>Hooks</span><span class=f>.</span><span class=d>register</span><span class=b>(</span><span class=j>:posts</span><span class=f>,</span><span class=j> :pre_render</span><span class=b>) </span><span class=k>do</span><span class=f> |</span><span class=b>document</span><span class=f>|</span></span>
<span class=a><span class=b>    content </span><span class=c>=</span><span class=b> document</span><span class=f>.</span><span class=d>content</span></span>
<span class=a><span class=b>    file </span><span class=c>=</span><span class=b> __dir__ </span><span class=c>+</span><span class=e> "/prism.min.js"</span></span>
<span class=a><span class=b>    source </span><span class=c>=</span><span class=h> File</span><span class=f>.</span><span class=d>read</span><span class=b>(file)</span></span>
<span class=a><span class=b>    js </span><span class=c>=</span><span class=h> ExecJS</span><span class=f>.</span><span class=d>compile</span><span class=b>(source)</span></span>
<span class=a><span class=b>    content</span><span class=f>.</span><span class=d>scan</span><span class=b> /</span><span class=l>((`{3})(?:\s*)(\w+)((?:.|\n)*?)\2)</span><span class=b>/</span><span class=k> do</span><span class=f> |</span><span class=b>match</span><span class=f>|</span></span>
<span class=a><span class=b>        code_block </span><span class=c>=</span><span class=b> match[</span><span class=j>0</span><span class=b>]</span></span>
<span class=a><span class=b>        language </span><span class=c>=</span><span class=b> match[</span><span class=j>2</span><span class=b>]</span></span>
<span class=a><span class=b>        code </span><span class=c>=</span><span class=b> match[</span><span class=j>3</span><span class=b>]</span></span>
<span class=a><span class=b>        js_code </span><span class=c>=</span><span class=e> %Q[Prism.highlight(`</span><span class=k>#{</span><span class=b>code</span><span class=k>}</span><span class=e>`, Prism.languages.</span><span class=k>#{</span><span class=b>language</span><span class=k>}</span><span class=e>, '</span><span class=k>#{</span><span class=b>language</span><span class=k>}</span><span class=e>')]</span></span>
<span class=a><span class=b>        output </span><span class=c>=</span><span class=b> js</span><span class=f>.</span><span class=m>eval</span><span class=b>(js_code)</span></span>
<span class=a><span class=b>        output </span><span class=c>=</span><span class=e> &#x3C;&#x3C;~EOS</span></span>
<span class=a><span class=e>        &#x3C;pre class="n o"s0">#{</span><span class=b>language</span><span class=k>}</span><span class=e>">&#x3C;code class='language-</span><span class=k>#{</span><span class=b>language</span><span class=k>}</span><span class=e>'></span><span class=k>#{</span><span class=b>output</span><span class=k>}</span><span class=e>&#x3C;/code>&#x3C;/pre></span></span>
<span class=a><span class=e>        EOS</span></span>
<span class=a><span class=b>        content </span><span class=c>=</span><span class=b> content</span><span class=f>.</span><span class=m>gsub</span><span class=b> code_block</span><span class=f>,</span><span class=b> output</span></span>
<span class=a><span class=k>    end</span></span>
<span class=a><span class=b>    document</span><span class=f>.</span><span class=d>content</span><span class=c> =</span><span class=b> content</span></span>
<span class=a><span class=k>end</span></span>
</code></pre><p>It works, but it has some bugs. If a code block contains a backtick, it breaks the call to the highlight function. So we need to escape special characters before we pass the code along. We can use the <a rel="noopener nofollow noreferrer external" target=_blank href=https://ruby-doc.org/stdlib-2.7.1/libdoc/json/rdoc/JSON.html>JSON</a> module for this, and we don't need to wrap it backticks.<pre><code><span class=a><span class=b>code </span><span class=c>=</span><span class=h> JSON</span><span class=f>.</span><span class=d>generate</span><span class=b>(match[</span><span class=j>3</span><span class=b>])</span></span>
<span class=a><span class=b>js_code </span><span class=c>=</span><span class=e> %Q[Prism.highlight(</span><span class=k>#{</span><span class=b>code</span><span class=k>}</span><span class=e>, Prism.languages.</span><span class=k>#{</span><span class=b>language</span><span class=k>}</span><span class=e>, '</span><span class=k>#{</span><span class=b>language</span><span class=k>}</span><span class=e>')]</span></span>
</code></pre><p>Finally, we have blogposts with pre-rendered syntax highlighting; without the need for JavaScript. All that's left is to include the CSS file to get the correct styling.<p>Future improvements would be to cache each block, so we don't need to render it each time if the code hasn't changed. Loading and compiling the JavaScript file also adds up to the build, and we could improve this by loading it once for the whole website. I left these improvements out; else, this blog post would get too long. Take a look at my current implementation to see the working version behind this blog. And if you see an improvement feel free to submit an MR!<p>*[Regex]: Regular Expressions *[MR]: Merge Request<div class=p id=1><sup class=q>1</sup><p>Liquid is the template rendering within Jekyll</div></section><footer>Published on <time datetime=2021-12-01T00:00:00 itemprop=datePublished>2021-12-01</time><br>Tags: <a href=/tags/#jekyll title="See all posts for Jekyll">Jekyll</a>, <a href=/tags/#prism title="See all posts for Prism">Prism</a>, <a href=/tags/#ruby title="See all posts for Ruby">Ruby</a>, <a href=/tags/#sustainablity title="See all posts for Sustainablity">Sustainablity</a><br>Source <a href=https:&#x2F;&#x2F;github.com&#x2F;brianvanburken&#x2F;brianvanburken.github.io&#x2F;tree&#x2F;master&#x2F;content/pre-render-syntax-highlighting-with-prism-in-jekyll.md target=_blank rel="noopener noreferrer" title="View post source on Github">on Github</a></footer></article><script data-goatcounter=https://brianvanburken.goatcounter.com/count async src=https://gc.zgo.at/count.js></script><noscript><img src="https://brianvanburken.goatcounter.com/count?p=/pre-render-syntax-highlighting-with-prism-in-jekyll/"></noscript>