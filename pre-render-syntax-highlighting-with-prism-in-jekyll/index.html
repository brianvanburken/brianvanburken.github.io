<!DOCTYPE html><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="data:,"><style>html{background:#0b0e14;color:#fff}body{font-family:Avenir Next,Open Sans,Helvetica,sans-serif;font-size:1.125rem;margin:1.5rem auto;max-width:70ch;padding:0 1.5rem}article,code,footer,h1,ol,p,pre{line-height:1.5rem;margin:1.5rem 0}h1{font-size:2.5rem;line-height:3rem}sup{font-size:.75rem;line-height:1}ol{padding-left:1.5rem}p{text-align:justify}img{max-width:100%}a{color:#fa3}a:visited{color:#ff9500}a:focus,a:hover{color:#ffbf66}footer{border-top:1px solid #bfbdb6;padding-top:1.5rem}code,pre{font-size:.875rem;word-break:normal;word-spacing:normal;word-wrap:normal;background:#0b0e14;border-radius:.375rem;color:#bfbdb6;hyphens:none}pre{overflow:auto;padding:1.5rem}p code{line-height:1;margin:0 2px;outline:3px solid #0b0e14}@media (prefers-color-scheme:light){html{background:#fff;color:#0b0e14}}.g{color:#39bae680}.k{color:#95e6cb}.l{color:#f07178}.h{color:#39bae6}.f{color:#bfbdb6b3}.d{color:#ffb454}.i{color:#d2a6ff}.c{color:#f29668}.j{color:#ff8f40}.e{color:#aad94c}</style><link type="application/atom+xml" rel="alternate" href="https://brianvanburken.nl/feed.xml" title="Brian van Burken"><title>Pre-render Syntax Highlighting with Prism in Jekyll | Brian van Burken</title><meta name="generator" content="Jekyll v4.4.1"><meta property="og:title" content="Pre-render Syntax Highlighting with Prism in Jekyll"><meta property="og:locale" content="en_US"><meta name="description" content="One of the most significant slowdowns of this blog was using Prism for syntax highlighting of code blocks. While Prism isn’t that big, adding more and more languages can make it grow large. If you wanted to write blog posts about all languages that Prism could support, you would end up with a 400kb+ monstrosity. I already have various blogposts for different languages, and I want to write about any language I like. So I wondered how to achieve this without slowing down my blog for my visitors."><meta property="og:description" content="One of the most significant slowdowns of this blog was using Prism for syntax highlighting of code blocks. While Prism isn’t that big, adding more and more languages can make it grow large. If you wanted to write blog posts about all languages that Prism could support, you would end up with a 400kb+ monstrosity. I already have various blogposts for different languages, and I want to write about any language I like. So I wondered how to achieve this without slowing down my blog for my visitors."><link rel="canonical" href="https://brianvanburken.nl/pre-render-syntax-highlighting-with-prism-in-jekyll/"><meta property="og:url" content="https://brianvanburken.nl/pre-render-syntax-highlighting-with-prism-in-jekyll/"><meta property="og:site_name" content="Brian van Burken"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-12-01T00:00:00+00:00"><meta name="twitter:card" content="summary"><meta property="twitter:title" content="Pre-render Syntax Highlighting with Prism in Jekyll"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-10-30T15:07:32+00:00","datePublished":"2021-12-01T00:00:00+00:00","description":"One of the most significant slowdowns of this blog was using Prism for syntax highlighting of code blocks. While Prism isn’t that big, adding more and more languages can make it grow large. If you wanted to write blog posts about all languages that Prism could support, you would end up with a 400kb+ monstrosity. I already have various blogposts for different languages, and I want to write about any language I like. So I wondered how to achieve this without slowing down my blog for my visitors.","headline":"Pre-render Syntax Highlighting with Prism in Jekyll","mainEntityOfPage":{"@type":"WebPage","@id":"https://brianvanburken.nl/pre-render-syntax-highlighting-with-prism-in-jekyll/"},"url":"https://brianvanburken.nl/pre-render-syntax-highlighting-with-prism-in-jekyll/"}</script><p><a href="/" title="Overview of all my writings">Writings</a> | <a href="https://github.com/brianvanburken" title="Visit my GitHub profile" target="_blank" rel="noopener noreferrer">GitHub</a> | <a href="https://linkedin.com/in/brianvanburken" title="Visit my LinkedIn profile" target="_blank" rel="noopener noreferrer">LinkedIn</a><article itemscope itemtype="http://schema.org/BlogPosting"><h1 itemprop="name headline">Pre-render Syntax Highlighting with Prism in Jekyll</h1><section itemprop="articleBody"><p>One of the most significant slowdowns of this blog was using <a href="https://prismjs.com/" target="_blank" rel="noopener noreferrer">Prism</a> for syntax highlighting of code blocks. While Prism isn’t that big, adding more and more languages can make it grow large. If you wanted to write blog posts about all languages that Prism could support, you would end up with a 400kb+ monstrosity. I already have various blogposts for different languages, and I want to write about any language I like. So I wondered how to achieve this without slowing down my blog for my visitors.<p>Since the output of Prism is HTML, I started looking into capturing this. My first attempt was to build a crawler that would go to each blogpost, execute JavaScript, and take the final rendered version to deploy. While this initially worked, it had a few challenges. One is the slowness of having to startup and render each page using a headless browser. Also, each rendered page still included the unwanted <code>script</code> tag to Prism.<p>After doing some more research, I decided to take a whole different approach. This time I would write my own Jekyll plugin. It extracts code blocks, passes them to the Prism highlight function, and returns the HTML output. The Prism highlight function takes three parameters: code, Prism language, code language. Executing the function would look like this.<pre tabindex="0"><code>Prism<span class="c">.</span><span class="d">highlight</span>(
<span class="e">  'var a = "Hello world!";'</span><span class="f">,</span>
  Prism<span class="c">.</span>languages<span class="c">.</span>javascript<span class="f">,</span>
<span class="e">  "javascript"</span>
)<span class="f">;</span>
</code></pre><p>And this would give us HTML with the syntax highlight tags added.<pre tabindex="0"><code><span class="g">&lt;</span><span class="h">span</span><span class="d"> class</span><span class="f">=</span><span class="e">"token keyword"</span><span class="g">&gt;</span>var<span class="g">&lt;/</span><span class="h">span</span><span class="g">&gt;</span> a <span class="g">&lt;</span><span class="h">span</span><span class="d"> class</span><span class="f">=</span><span class="e">"token operator"</span><span class="g">&gt;</span>=<span class="g">&lt;/</span><span class="h">span</span><span class="g">&gt;
&lt;</span><span class="h">span</span><span class="d"> class</span><span class="f">=</span><span class="e">"token string"</span><span class="g">&gt;</span>"Hello world!"<span class="g">&lt;/</span><span class="h">span</span>
<span class="g">&gt;&lt;</span><span class="h">span</span><span class="d"> class</span><span class="f">=</span><span class="e">"token punctuation"</span><span class="g">&gt;</span>;<span class="g">&lt;/</span><span class="h">span</span><span class="g">&gt;</span>
</code></pre><p>There are a few ways to achieve this. One would be to write a custom liquid-tag<sup id="fnref:1"><a href="#fn:1" rel="footnote" role="doc-noteref">1</a></sup> which would replace the code block in markdown. Another would be to listen for the pre-render event using Jekyll <a href="https://jekyllrb.com/docs/plugins/hooks/" target="_blank" rel="noopener noreferrer">Hooks</a> and then extract the code. I first went with the Liquid tag option and was successful. While it worked, all the markdown editors could not understand the custom tags and render a preview. So I finally decided to go with the hook option.<p><a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">Github Pages</a>, where I host my blog, doesn’t support custom plugins. So I switched from the <code>github-pages</code> gem to the <code>jekyll</code> gem and created my build process.<p>To create a custom plugin, I needed to create a directory in the project root called <code>_plugins</code> and place a Ruby file in it. Jekyll would then load this directory and its contents. I created a new file called <code>prism.rb</code> and placed it in <code>_plugins</code>.<p>Next, I added the <a href="https://github.com/rails/execjs" target="_blank" rel="noopener noreferrer">ExecJS</a> gem to the <code>Gemfile</code> and ran <code>bundle install</code>. ExecJS lets you run JavaScript code from Ruby. I use this to execute the Prism highlight function and capture its output.<p>In the <code>prism.rb</code> file, we can start adding hooks for events. The first hook would be to listen to the <code>pre_render</code> event on <code>posts</code>. The hook then gives us a <code>Jekyll::Document</code> from which we can ask the content of the blog post. It would look like this.<pre tabindex="0"><code><span class="h">Jekyll</span><span class="f">::</span><span class="h">Hooks</span><span class="f">.</span><span class="d">register</span>(<span class="i">:posts</span><span class="f">,</span><span class="i"> :pre_render</span>) <span class="j">do</span><span class="f"> |</span>document<span class="f">|</span>
    content <span class="c">=</span> document<span class="f">.</span><span class="d">content</span>
<span class="j">end</span>
</code></pre><p>Now that we have the blogpost content, we need to find all the code blocks present in the code. A code block starts with three backticks, followed by the language, on the following line the code, and ends with three backticks. I used <abbr title="Regular Expressions">Regex</abbr> to get the whole code block, language, and only the code. Using <code>String.scan</code>, we can get all the matches.<pre tabindex="0"><code><span class="h">Jekyll</span><span class="f">::</span><span class="h">Hooks</span><span class="f">.</span><span class="d">register</span>(<span class="i">:posts</span><span class="f">,</span><span class="i"> :pre_render</span>) <span class="j">do</span><span class="f"> |</span>document<span class="f">|</span>
    content <span class="c">=</span> document<span class="f">.</span><span class="d">content</span>
    content<span class="f">.</span><span class="d">scan</span> /<span class="k">((`{3})(?:\s*)(\w+)((?:.|\n)*?)\2)</span>/<span class="j"> do</span><span class="f"> |</span>match<span class="f">|</span>
        code_block <span class="c">=</span> match[<span class="i">0</span>]
        language <span class="c">=</span> match[<span class="i">2</span>]
        code <span class="c">=</span> match[<span class="i">3</span>]
<span class="j">    end
end</span>
</code></pre><p>Now we have everything to call the highlight function. To call the function, we need to start the JavaScript runtime and load Prism. First, we need to download Prism JavaScript code. You can do that <a href="https://prismjs.com/download.html" target="_blank" rel="noopener noreferrer">here</a>; while you’re at it, download the CSS file you’ll need later. I checked all the languages which you don’t have to. Note that checking all languages makes the file larger, thus making it longer to load and slowing down your build. My final <code>prism.min.js</code> file is a hefty 463kb on the disk; luckily, we don’t need to include this on the website! We can place the file in the <code>_plugins</code> directory next to our plugin <code>prism.rb</code>.<p>We then load the contents of our <code>prism.min.js</code> and pass it to <code>ExecJS.compile</code>. To do this, you add <code>require "execjs"</code> to the top of <code>prism.rb</code> and use <code>File.read</code> to load the JavaScript file. We place the loading and compiling of the JavaScript before the code block matching, so we don’t have to load it each time we come across a code block.<pre tabindex="0"><code><span class="f">...</span>
file <span class="c">=</span> __dir__ <span class="c">+</span><span class="e"> "/prism.min.js"</span>
source <span class="c">=</span><span class="h"> File</span><span class="f">.</span><span class="d">read</span>(file)
js <span class="c">=</span><span class="h"> ExecJS</span><span class="f">.</span><span class="d">compile</span>(source)
content<span class="f">.</span><span class="d">scan</span> /<span class="k">((`{3})(?:\s*)(\w+)((?:.|\n)*?)\2)</span>/<span class="j"> do</span><span class="f"> |</span>match<span class="f">|
...</span>
</code></pre><p>Next, we call the highlight function, using the compiled JavaScript for each of the code blocks. We then wrap the output with <code>pre</code> and <code>code</code> HTML tags and replace the code block in the blogpost with our pre-rendered HTML. Calling the function looks like this.<pre tabindex="0"><code>js_code <span class="c">=</span><span class="e"> %Q[Prism.highlight(`</span><span class="j">#{</span>code<span class="j">}</span><span class="e">`, Prism.languages.</span><span class="j">#{</span>language<span class="j">}</span><span class="e">, '</span><span class="j">#{</span>language<span class="j">}</span><span class="e">')]</span>
output <span class="c">=</span> js<span class="f">.</span><span class="l">eval</span>(js_code)
output <span class="c">=</span><span class="e"> &lt;&lt;~EOS
&lt;pre class="language-</span><span class="j">#{</span>language<span class="j">}</span><span class="e">"&gt;&lt;code class='language-</span><span class="j">#{</span>language<span class="j">}</span><span class="e">'&gt;</span><span class="j">#{</span>output<span class="j">}</span><span class="e">&lt;/code&gt;&lt;/pre&gt;
EOS</span>
</code></pre><p>Putting it all together, we get a working version.<pre tabindex="0"><code><span class="j">require</span><span class="e"> "execjs"</span>

<span class="h">Jekyll</span><span class="f">::</span><span class="h">Hooks</span><span class="f">.</span><span class="d">register</span>(<span class="i">:posts</span><span class="f">,</span><span class="i"> :pre_render</span>) <span class="j">do</span><span class="f"> |</span>document<span class="f">|</span>
    content <span class="c">=</span> document<span class="f">.</span><span class="d">content</span>
    file <span class="c">=</span> __dir__ <span class="c">+</span><span class="e"> "/prism.min.js"</span>
    source <span class="c">=</span><span class="h"> File</span><span class="f">.</span><span class="d">read</span>(file)
    js <span class="c">=</span><span class="h"> ExecJS</span><span class="f">.</span><span class="d">compile</span>(source)
    content<span class="f">.</span><span class="d">scan</span> /<span class="k">((`{3})(?:\s*)(\w+)((?:.|\n)*?)\2)</span>/<span class="j"> do</span><span class="f"> |</span>match<span class="f">|</span>
        code_block <span class="c">=</span> match[<span class="i">0</span>]
        language <span class="c">=</span> match[<span class="i">2</span>]
        code <span class="c">=</span> match[<span class="i">3</span>]
        js_code <span class="c">=</span><span class="e"> %Q[Prism.highlight(`</span><span class="j">#{</span>code<span class="j">}</span><span class="e">`, Prism.languages.</span><span class="j">#{</span>language<span class="j">}</span><span class="e">, '</span><span class="j">#{</span>language<span class="j">}</span><span class="e">')]</span>
        output <span class="c">=</span> js<span class="f">.</span><span class="l">eval</span>(js_code)
        output <span class="c">=</span><span class="e"> &lt;&lt;~EOS
        &lt;pre class="language-</span><span class="j">#{</span>language<span class="j">}</span><span class="e">"&gt;&lt;code class='language-</span><span class="j">#{</span>language<span class="j">}</span><span class="e">'&gt;</span><span class="j">#{</span>output<span class="j">}</span><span class="e">&lt;/code&gt;&lt;/pre&gt;
        EOS</span>
        content <span class="c">=</span> content<span class="f">.</span><span class="l">gsub</span> code_block<span class="f">,</span> output
<span class="j">    end</span>
    document<span class="f">.</span><span class="d">content</span><span class="c"> =</span> content
<span class="j">end</span>
</code></pre><p>It works, but it has some bugs. If a code block contains a backtick, it breaks the call to the highlight function. So we need to escape special characters before we pass the code along. We can use the <a href="https://ruby-doc.org/stdlib-2.7.1/libdoc/json/rdoc/JSON.html" target="_blank" rel="noopener noreferrer">JSON</a> module for this, and we don’t need to wrap it backticks.<pre tabindex="0"><code>code <span class="c">=</span><span class="h"> JSON</span><span class="f">.</span><span class="d">generate</span>(match[<span class="i">3</span>])
js_code <span class="c">=</span><span class="e"> %Q[Prism.highlight(</span><span class="j">#{</span>code<span class="j">}</span><span class="e">, Prism.languages.</span><span class="j">#{</span>language<span class="j">}</span><span class="e">, '</span><span class="j">#{</span>language<span class="j">}</span><span class="e">')]</span>
</code></pre><p>Finally, we have blogposts with pre-rendered syntax highlighting; without the need for JavaScript. All that’s left is to include the CSS file to get the correct styling.<p>Future improvements would be to cache each block, so we don’t need to render it each time if the code hasn’t changed. Loading and compiling the JavaScript file also adds up to the build, and we could improve this by loading it once for the whole website. I left these improvements out; else, this blog post would get too long. Take a look at my current implementation to see the working version behind this blog. And if you see an improvement feel free to submit an <abbr title="Merge Request">MR</abbr>!<div role="doc-endnotes"><ol><li id="fn:1"><p>Liquid is the template rendering within Jekyll&nbsp;<a href="#fnref:1" role="doc-backlink">↩</a></ol></div></section><footer>Published on <time datetime="2021-12-01T00:00:00+00:00" itemprop="datePublished">2021-12-01 </time><br>Tags: <a href="/tags/#jekyll" title="See all post for Jekyll">Jekyll</a>, <a href="/tags/#prism" title="See all post for Prism">Prism</a>, <a href="/tags/#ruby" title="See all post for Ruby">Ruby</a>, <a href="/tags/#sustainablity" title="See all post for Sustainablity">Sustainablity</a><br>Source <a href="https://github.com/brianvanburken/brianvanburken.github.io/tree/master/_posts/2021-12-01-pre-render-syntax-highlighting-with-prism-in-jekyll.md" target="_blank" rel="noopener noreferrer">on Github</a></footer></article><script data-goatcounter="https://brianvanburken.goatcounter.com/count" async src="https://gc.zgo.at/count.js"></script><noscript><img src="https://brianvanburken.goatcounter.com/count?p=/pre-render-syntax-highlighting-with-prism-in-jekyll/"></noscript>