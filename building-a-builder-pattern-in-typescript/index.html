<!DOCTYPE html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/atom+xml title="RSS Feed" href=https://brianvanburken.nl/feed.xml><title>Building A Builder Pattern in TypeScript | Brian van Burken</title><meta property=og:title content="Building A Builder Pattern in TypeScript"><meta name=description content="Forcing types using type assertions leave your code open for wrong assumptions. I went looking for an alternative."><meta property=og:description content="Forcing types using type assertions leave your code open for wrong assumptions. I went looking for an alternative."><meta property=og:type content=article><meta property=og:url content=https:&#x2F;&#x2F;brianvanburken.nl&#x2F;building-a-builder-pattern-in-typescript&#x2F;><meta property=og:site_name content="Brian van Burken"><link rel=canonical href=https:&#x2F;&#x2F;brianvanburken.nl&#x2F;building-a-builder-pattern-in-typescript&#x2F;><meta property=article:published_time content=2021-12-12T00:00:00+00:00><style>html{color:#fff;background:#0b0e14}@media (prefers-color-scheme:light){html{color:#0b0e14;background:#fff}}body{font-family:"Avenir Next","Open Sans",Helvetica,sans-serif;font-size:1.125rem;max-width:70ch;margin:1.5rem auto;padding:0 1.5rem}article,code,footer,h1,h2,h3,p,pre{margin:1.5rem 0;line-height:1.5rem}h1{font-size:2.5rem;line-height:3rem}p{text-align:justify}img{max-width:100%}h2{margin-top:3rem}blockquote{font-style:oblique;margin:1.5rem}a,a code{color:#fa3}a:visited{color:#ff9500}a:focus,a:hover{color:#ffbf66}footer{border-top:1px solid #bfbdb6;padding-top:1.5rem}code,pre{font-size:.875rem;word-spacing:normal;word-break:normal;word-wrap:normal;hyphens:none;color:#bfbdb6;background:#0b0e14;border-radius:.375rem}pre{overflow:auto;padding:1.5rem}p code{line-height:1;outline:3px solid #0b0e14;margin:0 2px}.b{color:#ff8f40}.c{color:#59c2ff}.d{color:#bfbdb6}.e{color:#f29668}.f{color:#39bae6}.g{color:#bfbdb6b3}.h{color:#aad94c}.i{color:#5a6673}.j{color:#ffb454}.k{color:#d2a6ff}</style><p><a href=/ title="Overview of all my writings">Writings</a> | <a href=https://github.com/brianvanburken title="Visit my GitHub profile" target=_blank rel="noopener noreferrer">GitHub</a> | <a href=https://linkedin.com/in/brianvanburken title="Visit my LinkedIn profile" target=_blank rel="noopener noreferrer">LinkedIn</a><article itemscope itemtype=http://schema.org/BlogPosting><h1 itemprop="name headline">Building A Builder Pattern in TypeScript</h1><section itemprop=articleBody><p>I've come across a few snippets of TypeScript where the type was forced on an object using <code>as</code>. Maybe you've seen those before too. I think using <code>as</code> is a bad thing and should be used as a last resort as you will lose type-safety, thus no help when the interface changes. I had doubts about its usage when the code needed a partial object before completion. So I went to search for other solutions and opinions.<p>Before discussing this further, let's create a scenario to be on the same page. Say we have the following interface:<pre><code><span class=a><span class=b>interface</span><span class=c> Foo</span><span class=d> {</span></span>
<span class=a><span class=d>  bar</span><span class=e>:</span><span class=f> string</span><span class=g>;</span></span>
<span class=a><span class=d>  baz</span><span class=e>:</span><span class=f> string</span><span class=g>;</span></span>
<span class=a><span class=d>}</span></span>
</code></pre><p>Here both <code>bar</code> and <code>baz</code> are required properties of <code>Foo</code>. Both must be present for the object to be complete. What if we wanted to first input <code>bar</code> and later input <code>baz</code>? There are few options to achieve this.<h2 id=type-assertions>Type assertions</h2><p>The first one is to enforce an object using <code>as</code>; this is called a <a rel="noopener nofollow noreferrer external" target=_blank href=https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions>"Type assertion"</a>. Below is an example of this.<pre><code><span class=a><span class=b>const</span><span class=d> foo </span><span class=e>=</span><span class=d> {</span></span>
<span class=a><span class=d>  bar</span><span class=g>:</span><span class=h> 'bar'</span></span>
<span class=a><span class=d>} </span><span class=b>as</span><span class=c> Foo</span><span class=g>;</span><span class=i> // Here we enforce the type</span></span>

<span class=a><span class=d>console</span><span class=e>.</span><span class=j>log</span><span class=d>(foo</span><span class=e>.</span><span class=d>baz)</span><span class=g>;</span><span class=i> // undefined</span></span>

<span class=a><span class=i>// Since `baz` isn't set, the following line could potentially crash if it does</span></span>
<span class=a><span class=i>// something with property `baz`</span></span>
<span class=a><span class=j>doSomethingWithFoo</span><span class=d>(foo)</span><span class=g>;</span></span>
</code></pre><p>The problem is the loss of type-safety. If you enforce a type, the compiler will think it's a complete object, and this will cause bugs later in your program.<h2 id=partial-utility-type>Partial Utility Type</h2><p>The other is to use <a rel="noopener nofollow noreferrer external" target=_blank href=https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype><code>Partial&lt;Type&gt;</code></a>; this is a Utility Type provided by TypeScript. Using the partial type, we can create a partial object to fill in the rest later. Usage would look as follows.<pre><code><span class=a><span class=b>const</span><span class=d> foo</span><span class=e>:</span><span class=c> Partial</span><span class=d>&#x3C;</span><span class=c>Foo</span><span class=d>> </span><span class=e>=</span><span class=d> {</span></span>
<span class=a><span class=d>  bar</span><span class=g>:</span><span class=h> 'bar'</span><span class=d>;</span></span>
<span class=a><span class=d>}</span><span class=g>;</span></span>

<span class=a><span class=d>console</span><span class=e>.</span><span class=j>log</span><span class=d>(foo</span><span class=e>.</span><span class=d>baz)</span><span class=g>;</span><span class=i> // undefined</span></span>

<span class=a><span class=i>// If our object is not complete and `doSomethingWithFoo` accepts only complete</span></span>
<span class=a><span class=i>// objects of `Foo` the compiler will throw an error</span></span>
<span class=a><span class=j>doSomethingWithFoo</span><span class=d>(foo)</span><span class=g>;</span></span>
</code></pre><p>It is the best of both approaches. The compiler guarantees safety and throws the error below if we pass the partial object along where the code expected a complete object.<pre><code>Argument of type &#39;Partial&lt;Foo&gt;&#39; is not assignable to parameter of type &#39;Foo&#39;.
  Types of property &#39;bar&#39; are incompatible.
    Type &#39;string | undefined&#39; is not assignable to type &#39;string&#39;.
      Type &#39;undefined&#39; is not assignable to type &#39;string&#39;.(2345)
</code></pre><p>The only problem with <code>Partial</code> is that it still allows us to work with properties of <code>Foo</code> even if they aren't set.<h2 id=builder-pattern>Builder Pattern</h2><p>What if we only want to work with a complete object and only access its properties? We needed some way to encapsulate the object until completed. There is a known design pattern that solves this. It is called the "Builder Pattern".<p>I've used this pattern in Java, and there I needed to write boilerplate such as setters for each property. Since JavaScript, and thus TypeScript, is dynamic, I went to look for a solution that also takes away this boilerplate code.<p>First, a quick recap of what a builder is and its usage. A builder is an encapsulation of a class or an interface. You can add a property with setters that start with <code>with</code>. In the case of Java, properties still can be optional; properties are by default <code>null</code>. Below is an example usage as you would use it in Java:<pre><code><span class=a><span class=b>new</span><span class=j> FooBuilder</span><span class=d>()</span></span>
<span class=a><span class=g>  .</span><span class=j>withBar</span><span class=d>(</span><span class=h>"bar"</span><span class=d>)</span></span>
<span class=a><span class=g>  .</span><span class=j>withBaz</span><span class=d>(</span><span class=h>"baz"</span><span class=d>)</span></span>
<span class=a><span class=g>  .</span><span class=j>build</span><span class=d>()</span><span class=g>;</span></span>
</code></pre><p>I wanted to achieve something similar with less boilerplate and more type inference. Also, I want to be as close to the conventions of Java.<h3 id=defining-the-type>Defining the type</h3><p>First off, I thought of the type of the pattern. Using <a rel="noopener nofollow noreferrer external" target=_blank href=https://www.typescriptlang.org/docs/handbook/2/keyof-types.html><code>keyof</code></a>, I could infer all the properties and types of an interface. With this, I could create a type that has all the properties. After some searching on the web, I also found the feature of TypeScript called <a rel="noopener nofollow noreferrer external" target=_blank href=https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html>"Template Literal Types"</a> that would help me create methods that start with <code>with</code>. Combining everything, I got the following type.<pre><code><span class=a><span class=b>type</span><span class=c> AbstractBuilder</span><span class=d>&#x3C;</span><span class=c>T</span><span class=g>,</span><span class=c> B</span><span class=e> =</span><span class=c> Record</span><span class=d>&#x3C;</span><span class=f>string</span><span class=g>,</span><span class=f> unknown</span><span class=d>>> </span><span class=e>=</span><span class=d> {</span></span>
<span class=a><span class=d>  [</span><span class=c>K</span><span class=e> in keyof</span><span class=c> T</span><span class=e> &#x26;</span><span class=f> string</span><span class=b> as</span><span class=h> `with</span><span class=b>${</span><span class=c>Capitalize</span><span class=d>&#x3C;</span><span class=c>K</span><span class=d>></span><span class=b>}</span><span class=h>`</span><span class=d>]</span><span class=e>:</span><span class=d> (</span><span class=k>arg</span><span class=e>:</span><span class=c> T</span><span class=d>[</span><span class=c>K</span><span class=d>]) </span><span class=b>=></span><span class=c> AbstractBuilder</span><span class=d>&#x3C;</span><span class=c>T</span><span class=g>,</span><span class=c> B</span><span class=e> &#x26;</span><span class=c> Record</span><span class=d>&#x3C;</span><span class=c>K</span><span class=g>,</span><span class=c> T</span><span class=d>[</span><span class=c>K</span><span class=d>]>></span><span class=g>;</span></span>
<span class=a><span class=d>}</span><span class=g>;</span></span>
</code></pre><p>A lot happens in a few lines. I'll explain each line in more detail.<p>Starting with our type <code>AbstractBuilder&lt;T, B = Record&lt;string, unknown&gt;&gt;</code>. Here we define <code>AbstractBuilder</code> that consists of two objects. First is the generic <code>T</code> that refers to the interface we want the builder to manage. The second, <code>B</code>, is the internal state of the builder. In my prototype, this was the <code>Partial</code> of <code>T</code>. But, changed it to a <code>Record</code> to solve a check I wanted to implement (more on that later).<p>The following line has the bulk of the type inference. It can be broken down into two parts, definition and assignment.<p>In the definition part, before the semicolon, we take each property from our generic <code>T</code> (the interface). Using <code>keyof</code>, we assign each property to type variable <code>K</code> and define it as a <code>string</code>. Then using <code>as</code>, here we only rename so we are save to use it, we redefine its to the template literal starting with <code>with</code> and follow by the property name capitalized. Our example with <code>Foo</code> gives us a property name <code>withBar</code> and <code>withBaz</code>.<p>In the assignment part, we assign a function to the property. The function takes one argument that must be of the same type as the property of the interface defined in <code>K</code>. This function then returns our <code>AbstractBuilder</code>, where our property and value type expand the state of <code>B</code>.<p>That last part will look as follows after you complete building <code>Foo</code>:<pre><code><span class=a><span class=d>AbstractBuilder</span><span class=e>&#x3C;</span></span>
<span class=a><span class=d>  Foo</span><span class=g>,</span></span>
<span class=a><span class=d>  Record</span><span class=e>&#x3C;</span><span class=d>string</span><span class=g>,</span><span class=d> unknown</span><span class=e>> &#x26;</span><span class=d> Record</span><span class=e>&#x3C;</span><span class=h>'bar'</span><span class=g>,</span><span class=d> string</span><span class=e>> &#x26;</span><span class=d> Record</span><span class=e>&#x3C;</span><span class=h>'baz'</span><span class=g>,</span><span class=d> string</span><span class=e>></span></span>
<span class=a><span class=e>></span></span>
</code></pre><p>Now that we have a type that expands a state until completed, we still need a way to get it. We extend our type with a new type that defines the final <code>build</code> method.<pre><code><span class=a><span class=b>type</span><span class=c> AbstractBuilder</span><span class=d>&#x3C;</span><span class=c>T</span><span class=g>,</span><span class=c> B</span><span class=e> =</span><span class=c> Record</span><span class=d>&#x3C;</span><span class=f>string</span><span class=g>,</span><span class=f> unknown</span><span class=d>>> </span><span class=e>=</span></span>
<span class=a><span class=d>  {</span><span class=e>...</span><span class=d>} </span></span>
<span class=a><span class=e>  &#x26;</span></span>
<span class=a><span class=d>  { build</span><span class=e>:</span><span class=c> B</span><span class=b> extends</span><span class=c> T</span><span class=e> ?</span><span class=d> () </span><span class=b>=></span><span class=c> T</span><span class=e> :</span><span class=f> never</span><span class=g>;</span><span class=d> }</span></span>
</code></pre><p>Here <code>build</code> returns our completed object of generic <code>T</code> if our internal state <code>B</code> is the same as <code>T</code>. If it is not the case, we return <code>never</code>. This trick enforces that we can only build a complete object and allows the compiler to tell us which properties are missing! Optional fields marked with <code>?</code> do not count towards a complete object.<h3 id=the-implementation>The implementation</h3><p>Now that we have a straightforward type, we can implement our Builder. One of my requirements was to prevent boilerplate code, writing our getters. So one of the things I started looking for was a "method missing" implementation like those in <a rel="noopener nofollow noreferrer external" target=_blank href=https://ruby-doc.org/core-2.7.3/BasicObject.html#method-i-method_missing>Ruby</a> and <a rel="noopener nofollow noreferrer external" target=_blank href=https://python-reference.readthedocs.io/en/latest/docs/dunderattr/getattr.html>Python</a>. After some searching, I came across ES6 <a rel="noopener nofollow noreferrer external" target=_blank href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy>Proxy</a> object.<p>A <code>Proxy</code> is, as <a rel="noopener nofollow noreferrer external" target=_blank href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy>MDN</a> describes it:<blockquote><p>The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.</blockquote><p>The part "intercept and redefine fundamental operations" is what we are interested in. After working with Proxy objects, I came up with the following implementation.<pre><code><span class=a><span class=b>function</span><span class=j> Builder</span><span class=d>&#x3C;</span><span class=c>T</span><span class=d>>() {</span></span>
<span class=a><span class=b>  const</span><span class=d> Builder </span><span class=e>= new</span><span class=j> Proxy</span><span class=d>(</span></span>
<span class=a><span class=d>    {}</span><span class=g>,</span></span>
<span class=a><span class=d>    {</span></span>
<span class=a><span class=j>      get</span><span class=d>(</span><span class=k>state</span><span class=e>:</span><span class=c> Record</span><span class=d>&#x3C;</span><span class=f>string</span><span class=g>,</span><span class=f> unknown</span><span class=d>></span><span class=g>,</span><span class=k> property</span><span class=e>:</span><span class=f> string</span><span class=d>) {</span></span>
<span class=a><span class=b>        if</span><span class=d> (property </span><span class=e>===</span><span class=h> "build"</span><span class=d>) {</span></span>
<span class=a><span class=b>          return</span><span class=d> () </span><span class=b>=></span><span class=d> state</span><span class=g>;</span></span>
<span class=a><span class=d>        }</span></span>

<span class=a><span class=b>        const</span><span class=d> prop </span><span class=e>=</span><span class=d> property</span><span class=e>.</span><span class=j>charAt</span><span class=d>(</span><span class=k>4</span><span class=d>)</span><span class=e>.</span><span class=j>toLowerCase</span><span class=d>() </span><span class=e>+</span><span class=d> property</span><span class=e>.</span><span class=j>slice</span><span class=d>(</span><span class=k>5</span><span class=d>)</span><span class=g>;</span></span>
<span class=a><span class=b>        return</span><span class=d> (</span><span class=k>x</span><span class=e>:</span><span class=f> unknown</span><span class=d>) </span><span class=b>=></span><span class=d> {</span></span>
<span class=a><span class=d>          state[prop] </span><span class=e>=</span><span class=d> x</span><span class=g>;</span></span>
<span class=a><span class=b>          return</span><span class=d> Builder</span><span class=g>;</span></span>
<span class=a><span class=d>        }</span><span class=g>;</span></span>
<span class=a><span class=d>      }</span><span class=g>,</span></span>
<span class=a><span class=d>    }</span></span>
<span class=a><span class=d>  ) </span><span class=b>as</span><span class=c> AbstractBuilder</span><span class=d>&#x3C;</span><span class=c>T</span><span class=d>></span><span class=g>;</span></span>

<span class=a><span class=b>  return</span><span class=d> Builder</span><span class=g>;</span></span>
<span class=a><span class=d>}</span></span>
</code></pre><p>Let me walk you through the code. First, we define the function <code>Builder</code>, which takes a generic <code>T</code> that is passed along to the <code>AbstractBuilder</code> type. The <code>T</code> references the interface we want the <code>Builder</code> to implement. The usage is then <code>Builder&lt;Foo&gt;()</code>.<p>We then define the Proxy and pass in our empty state and define the <code>get</code> method on the <code>Proxy</code>. This method receives our state and the property name we want to access, e.g. <code>"withBar"</code> or <code>"build"</code>. If we have <code>"build"</code>, we return our inner state and "finish" the Builder. Otherwise, take the property string, remove the with-prefix, and make the first character lowercase. This Builder assumes that you use property names that start with a lowercase character; if you diverge from this convention, you can change the code here to fit yours. We return a function that takes an argument of any type, updates the state with the property name, and returns the builder to continue chaining.<p>We still have to force the Proxy to follow our <code>AbstractBuilder</code> type. This is needed because the Proxy object is generic in itself. We can guarantee full type-safety in a complete object and set the right type for the right property using our type.<p>Here is an example showing the pattern in action using the <code>Foo</code> interface.<pre><code><span class=a><span class=j>Builder</span><span class=d>&#x3C;</span><span class=c>Foo</span><span class=d>>()</span></span>
<span class=a><span class=e>  .</span><span class=j>withBar</span><span class=d>(</span><span class=h>"bar"</span><span class=d>)</span></span>
<span class=a><span class=e>  .</span><span class=j>withBaz</span><span class=d>(</span><span class=h>"baz"</span><span class=d>)</span></span>
<span class=a><span class=e>  .</span><span class=j>build</span><span class=d>()</span><span class=g>;</span></span>
</code></pre><h2 id=should-you-use-it>Should you use it?</h2><p>Good question. It was an experiment to see what I wanted to implement was possible. I've successfully used this in a large application and without problems. Some colleagues were very enthusiastic about it, and others disliked it. I liked this pattern to build "Test Builders", where we would create a fully complete builder with test data and easily use it in our unit tests. So, it is up to you if you want to use it, easy to say, isn't it, and I recommend trying it yourself.</section><footer>Published on <time datetime=2021-12-12T00:00:00 itemprop=datePublished>2021-12-12</time><br>Tags: <a href=/tags/#generics title="See all posts for Generics">Generics</a>, <a href=/tags/#pattern title="See all posts for Pattern">Pattern</a>, <a href=/tags/#typescript title="See all posts for TypeScript">TypeScript</a><br>Source <a href=https:&#x2F;&#x2F;github.com&#x2F;brianvanburken&#x2F;brianvanburken.github.io&#x2F;tree&#x2F;master&#x2F;content/building-a-builder-pattern-in-typescript.md target=_blank rel="noopener noreferrer" title="View post source on Github">on Github</a></footer></article><script data-goatcounter=https://brianvanburken.goatcounter.com/count async src=https://gc.zgo.at/count.js></script><noscript><img src="https://brianvanburken.goatcounter.com/count?p=/building-a-builder-pattern-in-typescript/"></noscript>